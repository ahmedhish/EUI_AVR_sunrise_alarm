
Sunrise_alarm.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000013e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000142  00800060  000013e2  00001476  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000015  008001a2  008001a2  000015b8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000015b8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000015e8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000228  00000000  00000000  00001624  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000360f  00000000  00000000  0000184c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ec1  00000000  00000000  00004e5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001947  00000000  00000000  00005d1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000500  00000000  00000000  00007664  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010c4  00000000  00000000  00007b64  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000193b  00000000  00000000  00008c28  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000210  00000000  00000000  0000a563  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 6a 09 	jmp	0x12d4	; 0x12d4 <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 44 09 	jmp	0x1288	; 0x1288 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 8c 00 	jmp	0x118	; 0x118 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ee       	ldi	r30, 0xE2	; 226
      68:	f3 e1       	ldi	r31, 0x13	; 19
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3a       	cpi	r26, 0xA2	; 162
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	21 e0       	ldi	r18, 0x01	; 1
      78:	a2 ea       	ldi	r26, 0xA2	; 162
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 3b       	cpi	r26, 0xB7	; 183
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 bf 04 	call	0x97e	; 0x97e <main>
      8a:	0c 94 ef 09 	jmp	0x13de	; 0x13de <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ADC_Init_N>:
		status = conversion_NOTcomplete;
	}
	CLR_BIT(ADCSRA, ADIF);
	return status;
    
}
      92:	83 30       	cpi	r24, 0x03	; 3
      94:	38 f5       	brcc	.+78     	; 0xe4 <ADC_Init_N+0x52>
      96:	81 30       	cpi	r24, 0x01	; 1
      98:	89 f0       	breq	.+34     	; 0xbc <ADC_Init_N+0x2a>
      9a:	48 f0       	brcs	.+18     	; 0xae <ADC_Init_N+0x1c>
      9c:	82 30       	cpi	r24, 0x02	; 2
      9e:	a1 f4       	brne	.+40     	; 0xc8 <ADC_Init_N+0x36>
      a0:	87 b1       	in	r24, 0x07	; 7
      a2:	80 64       	ori	r24, 0x40	; 64
      a4:	87 b9       	out	0x07, r24	; 7
      a6:	87 b1       	in	r24, 0x07	; 7
      a8:	80 68       	ori	r24, 0x80	; 128
      aa:	87 b9       	out	0x07, r24	; 7
      ac:	0d c0       	rjmp	.+26     	; 0xc8 <ADC_Init_N+0x36>
      ae:	87 b1       	in	r24, 0x07	; 7
      b0:	8f 7b       	andi	r24, 0xBF	; 191
      b2:	87 b9       	out	0x07, r24	; 7
      b4:	87 b1       	in	r24, 0x07	; 7
      b6:	8f 77       	andi	r24, 0x7F	; 127
      b8:	87 b9       	out	0x07, r24	; 7
      ba:	06 c0       	rjmp	.+12     	; 0xc8 <ADC_Init_N+0x36>
      bc:	87 b1       	in	r24, 0x07	; 7
      be:	80 64       	ori	r24, 0x40	; 64
      c0:	87 b9       	out	0x07, r24	; 7
      c2:	87 b1       	in	r24, 0x07	; 7
      c4:	8f 77       	andi	r24, 0x7F	; 127
      c6:	87 b9       	out	0x07, r24	; 7
      c8:	86 b1       	in	r24, 0x06	; 6
      ca:	88 7f       	andi	r24, 0xF8	; 248
      cc:	86 b9       	out	0x06, r24	; 6
      ce:	68 30       	cpi	r22, 0x08	; 8
      d0:	58 f4       	brcc	.+22     	; 0xe8 <ADC_Init_N+0x56>
      d2:	67 70       	andi	r22, 0x07	; 7
      d4:	86 b1       	in	r24, 0x06	; 6
      d6:	68 2b       	or	r22, r24
      d8:	66 b9       	out	0x06, r22	; 6
      da:	86 b1       	in	r24, 0x06	; 6
      dc:	80 68       	ori	r24, 0x80	; 128
      de:	86 b9       	out	0x06, r24	; 6
      e0:	82 e0       	ldi	r24, 0x02	; 2
      e2:	08 95       	ret
      e4:	80 e0       	ldi	r24, 0x00	; 0
      e6:	08 95       	ret
      e8:	81 e0       	ldi	r24, 0x01	; 1
      ea:	08 95       	ret

000000ec <ADC_ReadChannel>:
      ec:	78 94       	sei
      ee:	97 b1       	in	r25, 0x07	; 7
      f0:	90 7e       	andi	r25, 0xE0	; 224
      f2:	97 b9       	out	0x07, r25	; 7
      f4:	88 30       	cpi	r24, 0x08	; 8
      f6:	70 f4       	brcc	.+28     	; 0x114 <ADC_ReadChannel+0x28>
      f8:	97 b1       	in	r25, 0x07	; 7
      fa:	90 7e       	andi	r25, 0xE0	; 224
      fc:	97 b9       	out	0x07, r25	; 7
      fe:	97 b1       	in	r25, 0x07	; 7
     100:	89 2b       	or	r24, r25
     102:	87 b9       	out	0x07, r24	; 7
     104:	86 b1       	in	r24, 0x06	; 6
     106:	80 64       	ori	r24, 0x40	; 64
     108:	86 b9       	out	0x06, r24	; 6
     10a:	86 b1       	in	r24, 0x06	; 6
     10c:	88 60       	ori	r24, 0x08	; 8
     10e:	86 b9       	out	0x06, r24	; 6
     110:	85 e0       	ldi	r24, 0x05	; 5
     112:	08 95       	ret
     114:	89 e0       	ldi	r24, 0x09	; 9
     116:	08 95       	ret

00000118 <__vector_16>:


ISR(ADC_vect)
{
     118:	1f 92       	push	r1
     11a:	0f 92       	push	r0
     11c:	0f b6       	in	r0, 0x3f	; 63
     11e:	0f 92       	push	r0
     120:	11 24       	eor	r1, r1
     122:	2f 93       	push	r18
     124:	3f 93       	push	r19
     126:	4f 93       	push	r20
     128:	5f 93       	push	r21
     12a:	6f 93       	push	r22
     12c:	7f 93       	push	r23
     12e:	8f 93       	push	r24
     130:	9f 93       	push	r25
     132:	af 93       	push	r26
     134:	bf 93       	push	r27

	Adc_Data = ((u16)ADC * 100) / 1023;
     136:	24 b1       	in	r18, 0x04	; 4
     138:	35 b1       	in	r19, 0x05	; 5
     13a:	44 e6       	ldi	r20, 0x64	; 100
     13c:	42 9f       	mul	r20, r18
     13e:	c0 01       	movw	r24, r0
     140:	43 9f       	mul	r20, r19
     142:	90 0d       	add	r25, r0
     144:	11 24       	eor	r1, r1
     146:	6f ef       	ldi	r22, 0xFF	; 255
     148:	73 e0       	ldi	r23, 0x03	; 3
     14a:	0e 94 93 09 	call	0x1326	; 0x1326 <__udivmodhi4>
     14e:	70 93 ab 01 	sts	0x01AB, r23	; 0x8001ab <Adc_Data+0x1>
     152:	60 93 aa 01 	sts	0x01AA, r22	; 0x8001aa <Adc_Data>
}
     156:	bf 91       	pop	r27
     158:	af 91       	pop	r26
     15a:	9f 91       	pop	r25
     15c:	8f 91       	pop	r24
     15e:	7f 91       	pop	r23
     160:	6f 91       	pop	r22
     162:	5f 91       	pop	r21
     164:	4f 91       	pop	r20
     166:	3f 91       	pop	r19
     168:	2f 91       	pop	r18
     16a:	0f 90       	pop	r0
     16c:	0f be       	out	0x3f, r0	; 63
     16e:	0f 90       	pop	r0
     170:	1f 90       	pop	r1
     172:	18 95       	reti

00000174 <BUZZER_TurnOn>:
         return ret_buzzer_error_status;       
}
enu_BUZZER_error_status_t BUZZER_TurnOn(enu_BUZZER_id_t buzzer_id)
{
    enu_BUZZER_error_status_t ret_buzzer_error_status = BUZZER_OK;
    if (buzzer_id > BUZZER_TOTAL)
     174:	82 30       	cpi	r24, 0x02	; 2
     176:	48 f4       	brcc	.+18     	; 0x18a <BUZZER_TurnOn+0x16>
    {
        ret_buzzer_error_status = BUZZER_NOK;
        return ret_buzzer_error_status;
    }

    switch (buzzer_id)
     178:	81 11       	cpse	r24, r1
     17a:	09 c0       	rjmp	.+18     	; 0x18e <BUZZER_TurnOn+0x1a>
    {
        case BUZZER1:
        DIO_SetPinValue(BUZZER1_PORT, BUZZER1_PIN, DIO_PIN_HIGH);
     17c:	41 e0       	ldi	r20, 0x01	; 1
     17e:	66 e0       	ldi	r22, 0x06	; 6
     180:	82 e0       	ldi	r24, 0x02	; 2
     182:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
        
         return ret_buzzer_error_status;       
}
enu_BUZZER_error_status_t BUZZER_TurnOn(enu_BUZZER_id_t buzzer_id)
{
    enu_BUZZER_error_status_t ret_buzzer_error_status = BUZZER_OK;
     186:	80 e0       	ldi	r24, 0x00	; 0

    switch (buzzer_id)
    {
        case BUZZER1:
        DIO_SetPinValue(BUZZER1_PORT, BUZZER1_PIN, DIO_PIN_HIGH);
        break;
     188:	08 95       	ret
{
    enu_BUZZER_error_status_t ret_buzzer_error_status = BUZZER_OK;
    if (buzzer_id > BUZZER_TOTAL)
    {
        ret_buzzer_error_status = BUZZER_NOK;
        return ret_buzzer_error_status;
     18a:	81 e0       	ldi	r24, 0x01	; 1
     18c:	08 95       	ret
    {
        case BUZZER1:
        DIO_SetPinValue(BUZZER1_PORT, BUZZER1_PIN, DIO_PIN_HIGH);
        break;
                    default:
                    ret_buzzer_error_status = BUZZER_NOK;
     18e:	81 e0       	ldi	r24, 0x01	; 1
                    break;
    }
    return ret_buzzer_error_status;         
}
     190:	08 95       	ret

00000192 <BUZZER_TurnOff>:
enu_BUZZER_error_status_t BUZZER_TurnOff(enu_BUZZER_id_t buzzer_id)
{
        enu_BUZZER_error_status_t ret_buzzer_error_status = BUZZER_OK;
        if (buzzer_id > BUZZER_TOTAL)
     192:	82 30       	cpi	r24, 0x02	; 2
     194:	48 f4       	brcc	.+18     	; 0x1a8 <BUZZER_TurnOff+0x16>
        {
            ret_buzzer_error_status = BUZZER_NOK;
            return ret_buzzer_error_status;
        }

        switch (buzzer_id)
     196:	81 11       	cpse	r24, r1
     198:	09 c0       	rjmp	.+18     	; 0x1ac <BUZZER_TurnOff+0x1a>
        {
            case BUZZER1:
            DIO_SetPinValue(BUZZER1_PORT, BUZZER1_PIN, DIO_PIN_LOW);
     19a:	40 e0       	ldi	r20, 0x00	; 0
     19c:	66 e0       	ldi	r22, 0x06	; 6
     19e:	82 e0       	ldi	r24, 0x02	; 2
     1a0:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    }
    return ret_buzzer_error_status;         
}
enu_BUZZER_error_status_t BUZZER_TurnOff(enu_BUZZER_id_t buzzer_id)
{
        enu_BUZZER_error_status_t ret_buzzer_error_status = BUZZER_OK;
     1a4:	80 e0       	ldi	r24, 0x00	; 0

        switch (buzzer_id)
        {
            case BUZZER1:
            DIO_SetPinValue(BUZZER1_PORT, BUZZER1_PIN, DIO_PIN_LOW);
            break;
     1a6:	08 95       	ret
{
        enu_BUZZER_error_status_t ret_buzzer_error_status = BUZZER_OK;
        if (buzzer_id > BUZZER_TOTAL)
        {
            ret_buzzer_error_status = BUZZER_NOK;
            return ret_buzzer_error_status;
     1a8:	81 e0       	ldi	r24, 0x01	; 1
     1aa:	08 95       	ret
        {
            case BUZZER1:
            DIO_SetPinValue(BUZZER1_PORT, BUZZER1_PIN, DIO_PIN_LOW);
            break;
            default:
            ret_buzzer_error_status = BUZZER_NOK;
     1ac:	81 e0       	ldi	r24, 0x01	; 1
            break;
        }
        return ret_buzzer_error_status;
     1ae:	08 95       	ret

000001b0 <DIO_SetPinDirection>:
        ret_dio_error_status = DIO_NOK;
        break;
    }

    return ret_dio_error_status;
}
     1b0:	44 23       	and	r20, r20
     1b2:	d9 f1       	breq	.+118    	; 0x22a <DIO_SetPinDirection+0x7a>
     1b4:	41 30       	cpi	r20, 0x01	; 1
     1b6:	09 f0       	breq	.+2      	; 0x1ba <DIO_SetPinDirection+0xa>
     1b8:	74 c0       	rjmp	.+232    	; 0x2a2 <DIO_SetPinDirection+0xf2>
     1ba:	81 30       	cpi	r24, 0x01	; 1
     1bc:	91 f0       	breq	.+36     	; 0x1e2 <DIO_SetPinDirection+0x32>
     1be:	28 f0       	brcs	.+10     	; 0x1ca <DIO_SetPinDirection+0x1a>
     1c0:	82 30       	cpi	r24, 0x02	; 2
     1c2:	d9 f0       	breq	.+54     	; 0x1fa <DIO_SetPinDirection+0x4a>
     1c4:	83 30       	cpi	r24, 0x03	; 3
     1c6:	29 f1       	breq	.+74     	; 0x212 <DIO_SetPinDirection+0x62>
     1c8:	6e c0       	rjmp	.+220    	; 0x2a6 <DIO_SetPinDirection+0xf6>
     1ca:	2a b3       	in	r18, 0x1a	; 26
     1cc:	81 e0       	ldi	r24, 0x01	; 1
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	02 c0       	rjmp	.+4      	; 0x1d6 <DIO_SetPinDirection+0x26>
     1d2:	88 0f       	add	r24, r24
     1d4:	99 1f       	adc	r25, r25
     1d6:	6a 95       	dec	r22
     1d8:	e2 f7       	brpl	.-8      	; 0x1d2 <DIO_SetPinDirection+0x22>
     1da:	82 2b       	or	r24, r18
     1dc:	8a bb       	out	0x1a, r24	; 26
     1de:	80 e0       	ldi	r24, 0x00	; 0
     1e0:	08 95       	ret
     1e2:	27 b3       	in	r18, 0x17	; 23
     1e4:	81 e0       	ldi	r24, 0x01	; 1
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	02 c0       	rjmp	.+4      	; 0x1ee <DIO_SetPinDirection+0x3e>
     1ea:	88 0f       	add	r24, r24
     1ec:	99 1f       	adc	r25, r25
     1ee:	6a 95       	dec	r22
     1f0:	e2 f7       	brpl	.-8      	; 0x1ea <DIO_SetPinDirection+0x3a>
     1f2:	82 2b       	or	r24, r18
     1f4:	87 bb       	out	0x17, r24	; 23
     1f6:	80 e0       	ldi	r24, 0x00	; 0
     1f8:	08 95       	ret
     1fa:	24 b3       	in	r18, 0x14	; 20
     1fc:	81 e0       	ldi	r24, 0x01	; 1
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	02 c0       	rjmp	.+4      	; 0x206 <DIO_SetPinDirection+0x56>
     202:	88 0f       	add	r24, r24
     204:	99 1f       	adc	r25, r25
     206:	6a 95       	dec	r22
     208:	e2 f7       	brpl	.-8      	; 0x202 <DIO_SetPinDirection+0x52>
     20a:	82 2b       	or	r24, r18
     20c:	84 bb       	out	0x14, r24	; 20
     20e:	80 e0       	ldi	r24, 0x00	; 0
     210:	08 95       	ret
     212:	21 b3       	in	r18, 0x11	; 17
     214:	81 e0       	ldi	r24, 0x01	; 1
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	02 c0       	rjmp	.+4      	; 0x21e <DIO_SetPinDirection+0x6e>
     21a:	88 0f       	add	r24, r24
     21c:	99 1f       	adc	r25, r25
     21e:	6a 95       	dec	r22
     220:	e2 f7       	brpl	.-8      	; 0x21a <DIO_SetPinDirection+0x6a>
     222:	82 2b       	or	r24, r18
     224:	81 bb       	out	0x11, r24	; 17
     226:	80 e0       	ldi	r24, 0x00	; 0
     228:	08 95       	ret
     22a:	81 30       	cpi	r24, 0x01	; 1
     22c:	99 f0       	breq	.+38     	; 0x254 <DIO_SetPinDirection+0xa4>
     22e:	28 f0       	brcs	.+10     	; 0x23a <DIO_SetPinDirection+0x8a>
     230:	82 30       	cpi	r24, 0x02	; 2
     232:	e9 f0       	breq	.+58     	; 0x26e <DIO_SetPinDirection+0xbe>
     234:	83 30       	cpi	r24, 0x03	; 3
     236:	41 f1       	breq	.+80     	; 0x288 <DIO_SetPinDirection+0xd8>
     238:	38 c0       	rjmp	.+112    	; 0x2aa <DIO_SetPinDirection+0xfa>
     23a:	2a b3       	in	r18, 0x1a	; 26
     23c:	81 e0       	ldi	r24, 0x01	; 1
     23e:	90 e0       	ldi	r25, 0x00	; 0
     240:	02 c0       	rjmp	.+4      	; 0x246 <DIO_SetPinDirection+0x96>
     242:	88 0f       	add	r24, r24
     244:	99 1f       	adc	r25, r25
     246:	6a 95       	dec	r22
     248:	e2 f7       	brpl	.-8      	; 0x242 <DIO_SetPinDirection+0x92>
     24a:	80 95       	com	r24
     24c:	82 23       	and	r24, r18
     24e:	8a bb       	out	0x1a, r24	; 26
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	08 95       	ret
     254:	27 b3       	in	r18, 0x17	; 23
     256:	81 e0       	ldi	r24, 0x01	; 1
     258:	90 e0       	ldi	r25, 0x00	; 0
     25a:	02 c0       	rjmp	.+4      	; 0x260 <DIO_SetPinDirection+0xb0>
     25c:	88 0f       	add	r24, r24
     25e:	99 1f       	adc	r25, r25
     260:	6a 95       	dec	r22
     262:	e2 f7       	brpl	.-8      	; 0x25c <DIO_SetPinDirection+0xac>
     264:	80 95       	com	r24
     266:	82 23       	and	r24, r18
     268:	87 bb       	out	0x17, r24	; 23
     26a:	81 e0       	ldi	r24, 0x01	; 1
     26c:	08 95       	ret
     26e:	24 b3       	in	r18, 0x14	; 20
     270:	81 e0       	ldi	r24, 0x01	; 1
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	02 c0       	rjmp	.+4      	; 0x27a <DIO_SetPinDirection+0xca>
     276:	88 0f       	add	r24, r24
     278:	99 1f       	adc	r25, r25
     27a:	6a 95       	dec	r22
     27c:	e2 f7       	brpl	.-8      	; 0x276 <DIO_SetPinDirection+0xc6>
     27e:	80 95       	com	r24
     280:	82 23       	and	r24, r18
     282:	84 bb       	out	0x14, r24	; 20
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	08 95       	ret
     288:	21 b3       	in	r18, 0x11	; 17
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	02 c0       	rjmp	.+4      	; 0x294 <DIO_SetPinDirection+0xe4>
     290:	88 0f       	add	r24, r24
     292:	99 1f       	adc	r25, r25
     294:	6a 95       	dec	r22
     296:	e2 f7       	brpl	.-8      	; 0x290 <DIO_SetPinDirection+0xe0>
     298:	80 95       	com	r24
     29a:	82 23       	and	r24, r18
     29c:	81 bb       	out	0x11, r24	; 17
     29e:	81 e0       	ldi	r24, 0x01	; 1
     2a0:	08 95       	ret
     2a2:	81 e0       	ldi	r24, 0x01	; 1
     2a4:	08 95       	ret
     2a6:	81 e0       	ldi	r24, 0x01	; 1
     2a8:	08 95       	ret
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	08 95       	ret

000002ae <DIO_SetPinValue>:
     2ae:	85 30       	cpi	r24, 0x05	; 5
     2b0:	08 f0       	brcs	.+2      	; 0x2b4 <DIO_SetPinValue+0x6>
     2b2:	7f c0       	rjmp	.+254    	; 0x3b2 <DIO_SetPinValue+0x104>
     2b4:	69 30       	cpi	r22, 0x09	; 9
     2b6:	08 f0       	brcs	.+2      	; 0x2ba <DIO_SetPinValue+0xc>
     2b8:	7e c0       	rjmp	.+252    	; 0x3b6 <DIO_SetPinValue+0x108>
     2ba:	43 30       	cpi	r20, 0x03	; 3
     2bc:	08 f0       	brcs	.+2      	; 0x2c0 <DIO_SetPinValue+0x12>
     2be:	7d c0       	rjmp	.+250    	; 0x3ba <DIO_SetPinValue+0x10c>
     2c0:	44 23       	and	r20, r20
     2c2:	d9 f1       	breq	.+118    	; 0x33a <DIO_SetPinValue+0x8c>
     2c4:	41 30       	cpi	r20, 0x01	; 1
     2c6:	09 f0       	breq	.+2      	; 0x2ca <DIO_SetPinValue+0x1c>
     2c8:	7a c0       	rjmp	.+244    	; 0x3be <DIO_SetPinValue+0x110>
     2ca:	81 30       	cpi	r24, 0x01	; 1
     2cc:	91 f0       	breq	.+36     	; 0x2f2 <DIO_SetPinValue+0x44>
     2ce:	28 f0       	brcs	.+10     	; 0x2da <DIO_SetPinValue+0x2c>
     2d0:	82 30       	cpi	r24, 0x02	; 2
     2d2:	d9 f0       	breq	.+54     	; 0x30a <DIO_SetPinValue+0x5c>
     2d4:	83 30       	cpi	r24, 0x03	; 3
     2d6:	29 f1       	breq	.+74     	; 0x322 <DIO_SetPinValue+0x74>
     2d8:	74 c0       	rjmp	.+232    	; 0x3c2 <DIO_SetPinValue+0x114>
     2da:	2b b3       	in	r18, 0x1b	; 27
     2dc:	81 e0       	ldi	r24, 0x01	; 1
     2de:	90 e0       	ldi	r25, 0x00	; 0
     2e0:	02 c0       	rjmp	.+4      	; 0x2e6 <DIO_SetPinValue+0x38>
     2e2:	88 0f       	add	r24, r24
     2e4:	99 1f       	adc	r25, r25
     2e6:	6a 95       	dec	r22
     2e8:	e2 f7       	brpl	.-8      	; 0x2e2 <DIO_SetPinValue+0x34>
     2ea:	82 2b       	or	r24, r18
     2ec:	8b bb       	out	0x1b, r24	; 27
     2ee:	80 e0       	ldi	r24, 0x00	; 0
     2f0:	08 95       	ret
     2f2:	28 b3       	in	r18, 0x18	; 24
     2f4:	81 e0       	ldi	r24, 0x01	; 1
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	02 c0       	rjmp	.+4      	; 0x2fe <DIO_SetPinValue+0x50>
     2fa:	88 0f       	add	r24, r24
     2fc:	99 1f       	adc	r25, r25
     2fe:	6a 95       	dec	r22
     300:	e2 f7       	brpl	.-8      	; 0x2fa <DIO_SetPinValue+0x4c>
     302:	82 2b       	or	r24, r18
     304:	88 bb       	out	0x18, r24	; 24
     306:	80 e0       	ldi	r24, 0x00	; 0
     308:	08 95       	ret
     30a:	25 b3       	in	r18, 0x15	; 21
     30c:	81 e0       	ldi	r24, 0x01	; 1
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	02 c0       	rjmp	.+4      	; 0x316 <DIO_SetPinValue+0x68>
     312:	88 0f       	add	r24, r24
     314:	99 1f       	adc	r25, r25
     316:	6a 95       	dec	r22
     318:	e2 f7       	brpl	.-8      	; 0x312 <DIO_SetPinValue+0x64>
     31a:	82 2b       	or	r24, r18
     31c:	85 bb       	out	0x15, r24	; 21
     31e:	80 e0       	ldi	r24, 0x00	; 0
     320:	08 95       	ret
     322:	22 b3       	in	r18, 0x12	; 18
     324:	81 e0       	ldi	r24, 0x01	; 1
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	02 c0       	rjmp	.+4      	; 0x32e <DIO_SetPinValue+0x80>
     32a:	88 0f       	add	r24, r24
     32c:	99 1f       	adc	r25, r25
     32e:	6a 95       	dec	r22
     330:	e2 f7       	brpl	.-8      	; 0x32a <DIO_SetPinValue+0x7c>
     332:	82 2b       	or	r24, r18
     334:	82 bb       	out	0x12, r24	; 18
     336:	80 e0       	ldi	r24, 0x00	; 0
     338:	08 95       	ret
     33a:	81 30       	cpi	r24, 0x01	; 1
     33c:	99 f0       	breq	.+38     	; 0x364 <DIO_SetPinValue+0xb6>
     33e:	28 f0       	brcs	.+10     	; 0x34a <DIO_SetPinValue+0x9c>
     340:	82 30       	cpi	r24, 0x02	; 2
     342:	e9 f0       	breq	.+58     	; 0x37e <DIO_SetPinValue+0xd0>
     344:	83 30       	cpi	r24, 0x03	; 3
     346:	41 f1       	breq	.+80     	; 0x398 <DIO_SetPinValue+0xea>
     348:	3e c0       	rjmp	.+124    	; 0x3c6 <DIO_SetPinValue+0x118>
     34a:	2b b3       	in	r18, 0x1b	; 27
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	02 c0       	rjmp	.+4      	; 0x356 <DIO_SetPinValue+0xa8>
     352:	88 0f       	add	r24, r24
     354:	99 1f       	adc	r25, r25
     356:	6a 95       	dec	r22
     358:	e2 f7       	brpl	.-8      	; 0x352 <DIO_SetPinValue+0xa4>
     35a:	80 95       	com	r24
     35c:	82 23       	and	r24, r18
     35e:	8b bb       	out	0x1b, r24	; 27
     360:	81 e0       	ldi	r24, 0x01	; 1
     362:	08 95       	ret
     364:	28 b3       	in	r18, 0x18	; 24
     366:	81 e0       	ldi	r24, 0x01	; 1
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	02 c0       	rjmp	.+4      	; 0x370 <DIO_SetPinValue+0xc2>
     36c:	88 0f       	add	r24, r24
     36e:	99 1f       	adc	r25, r25
     370:	6a 95       	dec	r22
     372:	e2 f7       	brpl	.-8      	; 0x36c <DIO_SetPinValue+0xbe>
     374:	80 95       	com	r24
     376:	82 23       	and	r24, r18
     378:	88 bb       	out	0x18, r24	; 24
     37a:	81 e0       	ldi	r24, 0x01	; 1
     37c:	08 95       	ret
     37e:	25 b3       	in	r18, 0x15	; 21
     380:	81 e0       	ldi	r24, 0x01	; 1
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	02 c0       	rjmp	.+4      	; 0x38a <DIO_SetPinValue+0xdc>
     386:	88 0f       	add	r24, r24
     388:	99 1f       	adc	r25, r25
     38a:	6a 95       	dec	r22
     38c:	e2 f7       	brpl	.-8      	; 0x386 <DIO_SetPinValue+0xd8>
     38e:	80 95       	com	r24
     390:	82 23       	and	r24, r18
     392:	85 bb       	out	0x15, r24	; 21
     394:	81 e0       	ldi	r24, 0x01	; 1
     396:	08 95       	ret
     398:	22 b3       	in	r18, 0x12	; 18
     39a:	81 e0       	ldi	r24, 0x01	; 1
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	02 c0       	rjmp	.+4      	; 0x3a4 <DIO_SetPinValue+0xf6>
     3a0:	88 0f       	add	r24, r24
     3a2:	99 1f       	adc	r25, r25
     3a4:	6a 95       	dec	r22
     3a6:	e2 f7       	brpl	.-8      	; 0x3a0 <DIO_SetPinValue+0xf2>
     3a8:	80 95       	com	r24
     3aa:	82 23       	and	r24, r18
     3ac:	82 bb       	out	0x12, r24	; 18
     3ae:	81 e0       	ldi	r24, 0x01	; 1
     3b0:	08 95       	ret
     3b2:	81 e0       	ldi	r24, 0x01	; 1
     3b4:	08 95       	ret
     3b6:	81 e0       	ldi	r24, 0x01	; 1
     3b8:	08 95       	ret
     3ba:	81 e0       	ldi	r24, 0x01	; 1
     3bc:	08 95       	ret
     3be:	81 e0       	ldi	r24, 0x01	; 1
     3c0:	08 95       	ret
     3c2:	81 e0       	ldi	r24, 0x01	; 1
     3c4:	08 95       	ret
     3c6:	81 e0       	ldi	r24, 0x01	; 1
     3c8:	08 95       	ret

000003ca <DIO_GetPinValue>:
     3ca:	85 30       	cpi	r24, 0x05	; 5
     3cc:	08 f0       	brcs	.+2      	; 0x3d0 <DIO_GetPinValue+0x6>
     3ce:	5b c0       	rjmp	.+182    	; 0x486 <__EEPROM_REGION_LENGTH__+0x86>
     3d0:	69 30       	cpi	r22, 0x09	; 9
     3d2:	08 f0       	brcs	.+2      	; 0x3d6 <DIO_GetPinValue+0xc>
     3d4:	5a c0       	rjmp	.+180    	; 0x48a <__EEPROM_REGION_LENGTH__+0x8a>
     3d6:	81 30       	cpi	r24, 0x01	; 1
     3d8:	d1 f0       	breq	.+52     	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
     3da:	28 f0       	brcs	.+10     	; 0x3e6 <DIO_GetPinValue+0x1c>
     3dc:	82 30       	cpi	r24, 0x02	; 2
     3de:	59 f1       	breq	.+86     	; 0x436 <__EEPROM_REGION_LENGTH__+0x36>
     3e0:	83 30       	cpi	r24, 0x03	; 3
     3e2:	e9 f1       	breq	.+122    	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
     3e4:	54 c0       	rjmp	.+168    	; 0x48e <__EEPROM_REGION_LENGTH__+0x8e>
     3e6:	89 b3       	in	r24, 0x19	; 25
     3e8:	90 e0       	ldi	r25, 0x00	; 0
     3ea:	06 2e       	mov	r0, r22
     3ec:	02 c0       	rjmp	.+4      	; 0x3f2 <DIO_GetPinValue+0x28>
     3ee:	95 95       	asr	r25
     3f0:	87 95       	ror	r24
     3f2:	0a 94       	dec	r0
     3f4:	e2 f7       	brpl	.-8      	; 0x3ee <DIO_GetPinValue+0x24>
     3f6:	81 70       	andi	r24, 0x01	; 1
     3f8:	fa 01       	movw	r30, r20
     3fa:	80 83       	st	Z, r24
     3fc:	89 b3       	in	r24, 0x19	; 25
     3fe:	90 e0       	ldi	r25, 0x00	; 0
     400:	02 c0       	rjmp	.+4      	; 0x406 <__EEPROM_REGION_LENGTH__+0x6>
     402:	95 95       	asr	r25
     404:	87 95       	ror	r24
     406:	6a 95       	dec	r22
     408:	e2 f7       	brpl	.-8      	; 0x402 <__EEPROM_REGION_LENGTH__+0x2>
     40a:	81 70       	andi	r24, 0x01	; 1
     40c:	08 95       	ret
     40e:	86 b3       	in	r24, 0x16	; 22
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	06 2e       	mov	r0, r22
     414:	02 c0       	rjmp	.+4      	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
     416:	95 95       	asr	r25
     418:	87 95       	ror	r24
     41a:	0a 94       	dec	r0
     41c:	e2 f7       	brpl	.-8      	; 0x416 <__EEPROM_REGION_LENGTH__+0x16>
     41e:	81 70       	andi	r24, 0x01	; 1
     420:	fa 01       	movw	r30, r20
     422:	80 83       	st	Z, r24
     424:	86 b3       	in	r24, 0x16	; 22
     426:	90 e0       	ldi	r25, 0x00	; 0
     428:	02 c0       	rjmp	.+4      	; 0x42e <__EEPROM_REGION_LENGTH__+0x2e>
     42a:	95 95       	asr	r25
     42c:	87 95       	ror	r24
     42e:	6a 95       	dec	r22
     430:	e2 f7       	brpl	.-8      	; 0x42a <__EEPROM_REGION_LENGTH__+0x2a>
     432:	81 70       	andi	r24, 0x01	; 1
     434:	08 95       	ret
     436:	83 b3       	in	r24, 0x13	; 19
     438:	90 e0       	ldi	r25, 0x00	; 0
     43a:	06 2e       	mov	r0, r22
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__EEPROM_REGION_LENGTH__+0x42>
     43e:	95 95       	asr	r25
     440:	87 95       	ror	r24
     442:	0a 94       	dec	r0
     444:	e2 f7       	brpl	.-8      	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
     446:	81 70       	andi	r24, 0x01	; 1
     448:	fa 01       	movw	r30, r20
     44a:	80 83       	st	Z, r24
     44c:	83 b3       	in	r24, 0x13	; 19
     44e:	90 e0       	ldi	r25, 0x00	; 0
     450:	02 c0       	rjmp	.+4      	; 0x456 <__EEPROM_REGION_LENGTH__+0x56>
     452:	95 95       	asr	r25
     454:	87 95       	ror	r24
     456:	6a 95       	dec	r22
     458:	e2 f7       	brpl	.-8      	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>
     45a:	81 70       	andi	r24, 0x01	; 1
     45c:	08 95       	ret
     45e:	80 b3       	in	r24, 0x10	; 16
     460:	90 e0       	ldi	r25, 0x00	; 0
     462:	06 2e       	mov	r0, r22
     464:	02 c0       	rjmp	.+4      	; 0x46a <__EEPROM_REGION_LENGTH__+0x6a>
     466:	95 95       	asr	r25
     468:	87 95       	ror	r24
     46a:	0a 94       	dec	r0
     46c:	e2 f7       	brpl	.-8      	; 0x466 <__EEPROM_REGION_LENGTH__+0x66>
     46e:	81 70       	andi	r24, 0x01	; 1
     470:	fa 01       	movw	r30, r20
     472:	80 83       	st	Z, r24
     474:	83 b3       	in	r24, 0x13	; 19
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	02 c0       	rjmp	.+4      	; 0x47e <__EEPROM_REGION_LENGTH__+0x7e>
     47a:	95 95       	asr	r25
     47c:	87 95       	ror	r24
     47e:	6a 95       	dec	r22
     480:	e2 f7       	brpl	.-8      	; 0x47a <__EEPROM_REGION_LENGTH__+0x7a>
     482:	81 70       	andi	r24, 0x01	; 1
     484:	08 95       	ret
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	08 95       	ret
     48a:	81 e0       	ldi	r24, 0x01	; 1
     48c:	08 95       	ret
     48e:	81 e0       	ldi	r24, 0x01	; 1
     490:	08 95       	ret

00000492 <DIO_SetPullUp>:
enu_dio_error_status_t DIO_SetPullUp(enu_dio_port_t DIO_PORTx, enu_dio_pin_t DIO_PINx)
{
    
    enu_dio_error_status_t ret_dio_error_status = DIO_OK;
    if ((DIO_PORTx > DIO_PORT_TOTAL) || (DIO_PINx > DIO_PIN_TOTAL))
     492:	85 30       	cpi	r24, 0x05	; 5
     494:	20 f4       	brcc	.+8      	; 0x49e <DIO_SetPullUp+0xc>
     496:	69 30       	cpi	r22, 0x09	; 9
     498:	20 f0       	brcs	.+8      	; 0x4a2 <DIO_SetPullUp+0x10>
    {
        ret_dio_error_status = DIO_NOK;
        return ret_dio_error_status;
     49a:	81 e0       	ldi	r24, 0x01	; 1
     49c:	08 95       	ret
     49e:	81 e0       	ldi	r24, 0x01	; 1
     4a0:	08 95       	ret
    }

    SET_BIT(DIO_PORTx, DIO_PINx);
    return ret_dio_error_status;
     4a2:	80 e0       	ldi	r24, 0x00	; 0
}
     4a4:	08 95       	ret

000004a6 <keyPad_Init>:
 const u8 KeyPad_Cols[KEYPAD_COLUMNS_NUMBER] = {KEYPAD_COLUMN0, KEYPAD_COLUMN1, KEYPAD_COLUMN2, KEYPAD_COLUMN3};
 const u8 KeyPad_Rows[KEYPAD_ROWS_NUMBER] = {KEYPAD_ROW0, KEYPAD_ROW1, KEYPAD_ROW2, KEYPAD_ROW3};

 void keyPad_Init(void)
 {
	 DIO_SetPinDirection(KEYPAD_COLUMN_PORT, KEYPAD_COLUMN0, DIO_PIN_INPUT);
     4a6:	40 e0       	ldi	r20, 0x00	; 0
     4a8:	67 e0       	ldi	r22, 0x07	; 7
     4aa:	83 e0       	ldi	r24, 0x03	; 3
     4ac:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
	 DIO_SetPinDirection(KEYPAD_COLUMN_PORT, KEYPAD_COLUMN1, DIO_PIN_INPUT);
     4b0:	40 e0       	ldi	r20, 0x00	; 0
     4b2:	66 e0       	ldi	r22, 0x06	; 6
     4b4:	83 e0       	ldi	r24, 0x03	; 3
     4b6:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
	 DIO_SetPinDirection(KEYPAD_COLUMN_PORT, KEYPAD_COLUMN2, DIO_PIN_INPUT);
     4ba:	40 e0       	ldi	r20, 0x00	; 0
     4bc:	65 e0       	ldi	r22, 0x05	; 5
     4be:	83 e0       	ldi	r24, 0x03	; 3
     4c0:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
	 DIO_SetPinDirection(KEYPAD_COLUMN_PORT, KEYPAD_COLUMN3, DIO_PIN_INPUT);
     4c4:	40 e0       	ldi	r20, 0x00	; 0
     4c6:	63 e0       	ldi	r22, 0x03	; 3
     4c8:	83 e0       	ldi	r24, 0x03	; 3
     4ca:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>

	 DIO_SetPinDirection(KEYPAD_ROW_PORT, KEYPAD_ROW0, DIO_PIN_INPUT);
     4ce:	40 e0       	ldi	r20, 0x00	; 0
     4d0:	65 e0       	ldi	r22, 0x05	; 5
     4d2:	82 e0       	ldi	r24, 0x02	; 2
     4d4:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
	 DIO_SetPinDirection(KEYPAD_ROW_PORT, KEYPAD_ROW1, DIO_PIN_INPUT);
     4d8:	40 e0       	ldi	r20, 0x00	; 0
     4da:	64 e0       	ldi	r22, 0x04	; 4
     4dc:	82 e0       	ldi	r24, 0x02	; 2
     4de:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
	 DIO_SetPinDirection(KEYPAD_ROW_PORT, KEYPAD_ROW2, DIO_PIN_INPUT);
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	63 e0       	ldi	r22, 0x03	; 3
     4e6:	82 e0       	ldi	r24, 0x02	; 2
     4e8:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
	 DIO_SetPinDirection(KEYPAD_ROW_PORT, KEYPAD_ROW3, DIO_PIN_INPUT);
     4ec:	40 e0       	ldi	r20, 0x00	; 0
     4ee:	62 e0       	ldi	r22, 0x02	; 2
     4f0:	82 e0       	ldi	r24, 0x02	; 2
     4f2:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>

	 DIO_SetPullUp(KEYPAD_ROW_PORT, KEYPAD_ROW0);
     4f6:	65 e0       	ldi	r22, 0x05	; 5
     4f8:	82 e0       	ldi	r24, 0x02	; 2
     4fa:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPullUp>
	 DIO_SetPullUp(KEYPAD_ROW_PORT, KEYPAD_ROW1);
     4fe:	64 e0       	ldi	r22, 0x04	; 4
     500:	82 e0       	ldi	r24, 0x02	; 2
     502:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPullUp>
	 DIO_SetPullUp(KEYPAD_ROW_PORT, KEYPAD_ROW2);
     506:	63 e0       	ldi	r22, 0x03	; 3
     508:	82 e0       	ldi	r24, 0x02	; 2
     50a:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPullUp>
	 DIO_SetPullUp(KEYPAD_ROW_PORT, KEYPAD_ROW3);
     50e:	62 e0       	ldi	r22, 0x02	; 2
     510:	82 e0       	ldi	r24, 0x02	; 2
     512:	0e 94 49 02 	call	0x492	; 0x492 <DIO_SetPullUp>
     516:	08 95       	ret

00000518 <KeyPad_GetValue>:
 }

KEYPAD_ERROR_T  KeyPad_GetValue(void)
{
     518:	af 92       	push	r10
     51a:	bf 92       	push	r11
     51c:	cf 92       	push	r12
     51e:	df 92       	push	r13
     520:	ef 92       	push	r14
     522:	ff 92       	push	r15
     524:	0f 93       	push	r16
     526:	1f 93       	push	r17
     528:	cf 93       	push	r28
     52a:	df 93       	push	r29
     52c:	1f 92       	push	r1
     52e:	cd b7       	in	r28, 0x3d	; 61
     530:	de b7       	in	r29, 0x3e	; 62
	u8 cols = 0;
	u8 rows = 0;
	KEYPAD_ERROR_T status=NOT_PRESSED ;
	u8 Pin_value;

	for (rows = 0; rows < KEYPAD_ROWS_NUMBER; ++rows)
     532:	b1 2c       	mov	r11, r1
     534:	4a c0       	rjmp	.+148    	; 0x5ca <KeyPad_GetValue+0xb2>
	{
		DIO_SetPinDirection(KEYPAD_ROW_PORT, KeyPad_Rows[rows], DIO_PIN_OUTPUT);
     536:	cb 2c       	mov	r12, r11
     538:	d1 2c       	mov	r13, r1
     53a:	f6 01       	movw	r30, r12
     53c:	e1 59       	subi	r30, 0x91	; 145
     53e:	ff 4f       	sbci	r31, 0xFF	; 255
     540:	a0 80       	ld	r10, Z
     542:	41 e0       	ldi	r20, 0x01	; 1
     544:	6a 2d       	mov	r22, r10
     546:	82 e0       	ldi	r24, 0x02	; 2
     548:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
		DIO_SetPinValue(KEYPAD_ROW_PORT, KeyPad_Rows[rows], DIO_PIN_LOW);
     54c:	40 e0       	ldi	r20, 0x00	; 0
     54e:	6a 2d       	mov	r22, r10
     550:	82 e0       	ldi	r24, 0x02	; 2
     552:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>

		for (cols = 0; cols < KEYPAD_COLUMNS_NUMBER; ++cols)
     556:	10 e0       	ldi	r17, 0x00	; 0
     558:	30 c0       	rjmp	.+96     	; 0x5ba <KeyPad_GetValue+0xa2>
		{
			DIO_GetPinValue(KEYPAD_COLUMN_PORT, KeyPad_Cols[cols],&Pin_value);
     55a:	e1 2e       	mov	r14, r17
     55c:	f1 2c       	mov	r15, r1
     55e:	f7 01       	movw	r30, r14
     560:	ed 58       	subi	r30, 0x8D	; 141
     562:	ff 4f       	sbci	r31, 0xFF	; 255
     564:	00 81       	ld	r16, Z
     566:	ae 01       	movw	r20, r28
     568:	4f 5f       	subi	r20, 0xFF	; 255
     56a:	5f 4f       	sbci	r21, 0xFF	; 255
     56c:	60 2f       	mov	r22, r16
     56e:	83 e0       	ldi	r24, 0x03	; 3
     570:	0e 94 e5 01 	call	0x3ca	; 0x3ca <DIO_GetPinValue>
			if (Pin_value == DIO_PIN_LOW)
     574:	89 81       	ldd	r24, Y+1	; 0x01
     576:	81 11       	cpse	r24, r1
     578:	1f c0       	rjmp	.+62     	; 0x5b8 <KeyPad_GetValue+0xa0>
     57a:	07 c0       	rjmp	.+14     	; 0x58a <KeyPad_GetValue+0x72>
			{
				while (Pin_value == DIO_PIN_LOW){
					DIO_GetPinValue(KEYPAD_COLUMN_PORT, KeyPad_Cols[cols],&Pin_value);
     57c:	ae 01       	movw	r20, r28
     57e:	4f 5f       	subi	r20, 0xFF	; 255
     580:	5f 4f       	sbci	r21, 0xFF	; 255
     582:	60 2f       	mov	r22, r16
     584:	83 e0       	ldi	r24, 0x03	; 3
     586:	0e 94 e5 01 	call	0x3ca	; 0x3ca <DIO_GetPinValue>
		for (cols = 0; cols < KEYPAD_COLUMNS_NUMBER; ++cols)
		{
			DIO_GetPinValue(KEYPAD_COLUMN_PORT, KeyPad_Cols[cols],&Pin_value);
			if (Pin_value == DIO_PIN_LOW)
			{
				while (Pin_value == DIO_PIN_LOW){
     58a:	89 81       	ldd	r24, Y+1	; 0x01
     58c:	88 23       	and	r24, r24
     58e:	b1 f3       	breq	.-20     	; 0x57c <KeyPad_GetValue+0x64>
					DIO_GetPinValue(KEYPAD_COLUMN_PORT, KeyPad_Cols[cols],&Pin_value);
				}
				DIO_SetPinDirection(KEYPAD_ROW_PORT, KeyPad_Rows[rows], DIO_PIN_INPUT);
     590:	40 e0       	ldi	r20, 0x00	; 0
     592:	6a 2d       	mov	r22, r10
     594:	82 e0       	ldi	r24, 0x02	; 2
     596:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
				key= KeyPad_Values[rows][cols];
     59a:	c6 01       	movw	r24, r12
     59c:	88 0f       	add	r24, r24
     59e:	99 1f       	adc	r25, r25
     5a0:	88 0f       	add	r24, r24
     5a2:	99 1f       	adc	r25, r25
     5a4:	89 58       	subi	r24, 0x89	; 137
     5a6:	9f 4f       	sbci	r25, 0xFF	; 255
     5a8:	fc 01       	movw	r30, r24
     5aa:	ee 0d       	add	r30, r14
     5ac:	ff 1d       	adc	r31, r15
     5ae:	80 81       	ld	r24, Z
     5b0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
				status =PRESSED;
				return status;
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	0e c0       	rjmp	.+28     	; 0x5d4 <KeyPad_GetValue+0xbc>
	for (rows = 0; rows < KEYPAD_ROWS_NUMBER; ++rows)
	{
		DIO_SetPinDirection(KEYPAD_ROW_PORT, KeyPad_Rows[rows], DIO_PIN_OUTPUT);
		DIO_SetPinValue(KEYPAD_ROW_PORT, KeyPad_Rows[rows], DIO_PIN_LOW);

		for (cols = 0; cols < KEYPAD_COLUMNS_NUMBER; ++cols)
     5b8:	1f 5f       	subi	r17, 0xFF	; 255
     5ba:	14 30       	cpi	r17, 0x04	; 4
     5bc:	70 f2       	brcs	.-100    	; 0x55a <KeyPad_GetValue+0x42>
				return status;
				
			}
		}

		DIO_SetPinDirection(KEYPAD_ROW_PORT, KeyPad_Rows[rows], DIO_PIN_INPUT);
     5be:	40 e0       	ldi	r20, 0x00	; 0
     5c0:	6a 2d       	mov	r22, r10
     5c2:	82 e0       	ldi	r24, 0x02	; 2
     5c4:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
	u8 cols = 0;
	u8 rows = 0;
	KEYPAD_ERROR_T status=NOT_PRESSED ;
	u8 Pin_value;

	for (rows = 0; rows < KEYPAD_ROWS_NUMBER; ++rows)
     5c8:	b3 94       	inc	r11
     5ca:	83 e0       	ldi	r24, 0x03	; 3
     5cc:	8b 15       	cp	r24, r11
     5ce:	08 f0       	brcs	.+2      	; 0x5d2 <KeyPad_GetValue+0xba>
     5d0:	b2 cf       	rjmp	.-156    	; 0x536 <KeyPad_GetValue+0x1e>
		}

		DIO_SetPinDirection(KEYPAD_ROW_PORT, KeyPad_Rows[rows], DIO_PIN_INPUT);
	}

	return status;
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	0f 90       	pop	r0
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	1f 91       	pop	r17
     5dc:	0f 91       	pop	r16
     5de:	ff 90       	pop	r15
     5e0:	ef 90       	pop	r14
     5e2:	df 90       	pop	r13
     5e4:	cf 90       	pop	r12
     5e6:	bf 90       	pop	r11
     5e8:	af 90       	pop	r10
     5ea:	08 95       	ret

000005ec <LCD_WriteCommand>:
    
    
}

void LCD_WriteCommand(u8 cmd)
{
     5ec:	cf 93       	push	r28
     5ee:	c8 2f       	mov	r28, r24
    /*
    RS (Register Select)
    RS = 0 -> Command Register is selected
    */
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_RS_PIN ,DIO_PIN_LOW);
     5f0:	40 e0       	ldi	r20, 0x00	; 0
     5f2:	63 e0       	ldi	r22, 0x03	; 3
     5f4:	80 e0       	ldi	r24, 0x00	; 0
     5f6:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     5fa:	8f e9       	ldi	r24, 0x9F	; 159
     5fc:	9f e0       	ldi	r25, 0x0F	; 15
     5fe:	01 97       	sbiw	r24, 0x01	; 1
     600:	f1 f7       	brne	.-4      	; 0x5fe <LCD_WriteCommand+0x12>
     602:	00 c0       	rjmp	.+0      	; 0x604 <LCD_WriteCommand+0x18>
     604:	00 00       	nop
    For 4-bit interface data, only four bus lines (DB4 to DB7) are used for transfer. Bus lines DB0 to DB3
    are disabled. The data transfer between the HD44780U and the MPU is completed after the 4-bit data
    has been transferred twice. As for the order of data transfer, the four high order bits (for 8-bit operation,
    DB4 to DB7) are transferred before the four low order bits (for 8-bit operation, DB0 to DB3).
    */
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D4 , GET_BIT(cmd,4));
     606:	c4 fb       	bst	r28, 4
     608:	44 27       	eor	r20, r20
     60a:	40 f9       	bld	r20, 0
     60c:	60 e0       	ldi	r22, 0x00	; 0
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D5 , GET_BIT(cmd,5));
     614:	c5 fb       	bst	r28, 5
     616:	44 27       	eor	r20, r20
     618:	40 f9       	bld	r20, 0
     61a:	61 e0       	ldi	r22, 0x01	; 1
     61c:	81 e0       	ldi	r24, 0x01	; 1
     61e:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D6 , GET_BIT(cmd,6));
     622:	c6 fb       	bst	r28, 6
     624:	44 27       	eor	r20, r20
     626:	40 f9       	bld	r20, 0
     628:	62 e0       	ldi	r22, 0x02	; 2
     62a:	81 e0       	ldi	r24, 0x01	; 1
     62c:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D7 , GET_BIT(cmd,7));
     630:	4c 2f       	mov	r20, r28
     632:	44 1f       	adc	r20, r20
     634:	44 27       	eor	r20, r20
     636:	44 1f       	adc	r20, r20
     638:	64 e0       	ldi	r22, 0x04	; 4
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     640:	8f e9       	ldi	r24, 0x9F	; 159
     642:	9f e0       	ldi	r25, 0x0F	; 15
     644:	01 97       	sbiw	r24, 0x01	; 1
     646:	f1 f7       	brne	.-4      	; 0x644 <LCD_WriteCommand+0x58>
     648:	00 c0       	rjmp	.+0      	; 0x64a <LCD_WriteCommand+0x5e>
     64a:	00 00       	nop
    
    
    /*
    Falling Edge to process the data
    */
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_EN_PIN ,DIO_PIN_HIGH);
     64c:	41 e0       	ldi	r20, 0x01	; 1
     64e:	62 e0       	ldi	r22, 0x02	; 2
     650:	80 e0       	ldi	r24, 0x00	; 0
     652:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     656:	8f e9       	ldi	r24, 0x9F	; 159
     658:	9f e0       	ldi	r25, 0x0F	; 15
     65a:	01 97       	sbiw	r24, 0x01	; 1
     65c:	f1 f7       	brne	.-4      	; 0x65a <LCD_WriteCommand+0x6e>
     65e:	00 c0       	rjmp	.+0      	; 0x660 <LCD_WriteCommand+0x74>
     660:	00 00       	nop
    _delay_ms(1);
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_EN_PIN ,DIO_PIN_LOW);      
     662:	40 e0       	ldi	r20, 0x00	; 0
     664:	62 e0       	ldi	r22, 0x02	; 2
     666:	80 e0       	ldi	r24, 0x00	; 0
     668:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     66c:	8f e9       	ldi	r24, 0x9F	; 159
     66e:	9f e0       	ldi	r25, 0x0F	; 15
     670:	01 97       	sbiw	r24, 0x01	; 1
     672:	f1 f7       	brne	.-4      	; 0x670 <LCD_WriteCommand+0x84>
     674:	00 c0       	rjmp	.+0      	; 0x676 <LCD_WriteCommand+0x8a>
     676:	00 00       	nop
    _delay_ms(1);


    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D4 , GET_BIT(cmd,0));
     678:	4c 2f       	mov	r20, r28
     67a:	41 70       	andi	r20, 0x01	; 1
     67c:	60 e0       	ldi	r22, 0x00	; 0
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D5 , GET_BIT(cmd,1));
     684:	c1 fb       	bst	r28, 1
     686:	44 27       	eor	r20, r20
     688:	40 f9       	bld	r20, 0
     68a:	61 e0       	ldi	r22, 0x01	; 1
     68c:	81 e0       	ldi	r24, 0x01	; 1
     68e:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D6 , GET_BIT(cmd,2));
     692:	c2 fb       	bst	r28, 2
     694:	44 27       	eor	r20, r20
     696:	40 f9       	bld	r20, 0
     698:	62 e0       	ldi	r22, 0x02	; 2
     69a:	81 e0       	ldi	r24, 0x01	; 1
     69c:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D7 , GET_BIT(cmd,3));
     6a0:	c3 fb       	bst	r28, 3
     6a2:	44 27       	eor	r20, r20
     6a4:	40 f9       	bld	r20, 0
     6a6:	64 e0       	ldi	r22, 0x04	; 4
     6a8:	81 e0       	ldi	r24, 0x01	; 1
     6aa:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     6ae:	8f e9       	ldi	r24, 0x9F	; 159
     6b0:	9f e0       	ldi	r25, 0x0F	; 15
     6b2:	01 97       	sbiw	r24, 0x01	; 1
     6b4:	f1 f7       	brne	.-4      	; 0x6b2 <LCD_WriteCommand+0xc6>
     6b6:	00 c0       	rjmp	.+0      	; 0x6b8 <LCD_WriteCommand+0xcc>
     6b8:	00 00       	nop
    _delay_ms(1);
    
    /*
    Falling Edge to process the data
    */
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_EN_PIN ,DIO_PIN_HIGH);     
     6ba:	41 e0       	ldi	r20, 0x01	; 1
     6bc:	62 e0       	ldi	r22, 0x02	; 2
     6be:	80 e0       	ldi	r24, 0x00	; 0
     6c0:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     6c4:	8f e9       	ldi	r24, 0x9F	; 159
     6c6:	9f e0       	ldi	r25, 0x0F	; 15
     6c8:	01 97       	sbiw	r24, 0x01	; 1
     6ca:	f1 f7       	brne	.-4      	; 0x6c8 <LCD_WriteCommand+0xdc>
     6cc:	00 c0       	rjmp	.+0      	; 0x6ce <LCD_WriteCommand+0xe2>
     6ce:	00 00       	nop
    _delay_ms(1);
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_EN_PIN ,DIO_PIN_LOW);
     6d0:	40 e0       	ldi	r20, 0x00	; 0
     6d2:	62 e0       	ldi	r22, 0x02	; 2
     6d4:	80 e0       	ldi	r24, 0x00	; 0
     6d6:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     6da:	8f e1       	ldi	r24, 0x1F	; 31
     6dc:	9e e4       	ldi	r25, 0x4E	; 78
     6de:	01 97       	sbiw	r24, 0x01	; 1
     6e0:	f1 f7       	brne	.-4      	; 0x6de <LCD_WriteCommand+0xf2>
     6e2:	00 c0       	rjmp	.+0      	; 0x6e4 <LCD_WriteCommand+0xf8>
     6e4:	00 00       	nop
    
    _delay_ms(5); /*LCD store delay*/
}
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <LCD_Init>:
/*https://www.8051projects.net/lcd-interfacing/commands.php*/

void LCD_Init(void)
{
    
    DIO_SetPinDirection(LCD_4BIT_CMD_PORT ,LCD_RS_PIN ,DIO_PIN_OUTPUT);
     6ea:	41 e0       	ldi	r20, 0x01	; 1
     6ec:	63 e0       	ldi	r22, 0x03	; 3
     6ee:	80 e0       	ldi	r24, 0x00	; 0
     6f0:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
    /*DIO_SetPinDir(LCD_4BIT_CMD_PORT ,LCD_RW_PIN ,DIO_PIN_OUTPUT);*/
    DIO_SetPinDirection(LCD_4BIT_CMD_PORT ,LCD_EN_PIN ,DIO_PIN_OUTPUT);
     6f4:	41 e0       	ldi	r20, 0x01	; 1
     6f6:	62 e0       	ldi	r22, 0x02	; 2
     6f8:	80 e0       	ldi	r24, 0x00	; 0
     6fa:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
    
    DIO_SetPinDirection(LCD_4BIT_DATA_PORT ,LCD_D4 ,DIO_PIN_OUTPUT);
     6fe:	41 e0       	ldi	r20, 0x01	; 1
     700:	60 e0       	ldi	r22, 0x00	; 0
     702:	81 e0       	ldi	r24, 0x01	; 1
     704:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_4BIT_DATA_PORT ,LCD_D5 ,DIO_PIN_OUTPUT);
     708:	41 e0       	ldi	r20, 0x01	; 1
     70a:	61 e0       	ldi	r22, 0x01	; 1
     70c:	81 e0       	ldi	r24, 0x01	; 1
     70e:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_4BIT_DATA_PORT ,LCD_D6 ,DIO_PIN_OUTPUT);
     712:	41 e0       	ldi	r20, 0x01	; 1
     714:	62 e0       	ldi	r22, 0x02	; 2
     716:	81 e0       	ldi	r24, 0x01	; 1
     718:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
    DIO_SetPinDirection(LCD_4BIT_DATA_PORT ,LCD_D7 ,DIO_PIN_OUTPUT);
     71c:	41 e0       	ldi	r20, 0x01	; 1
     71e:	64 e0       	ldi	r22, 0x04	; 4
     720:	81 e0       	ldi	r24, 0x01	; 1
     722:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
     726:	8f e9       	ldi	r24, 0x9F	; 159
     728:	9f e0       	ldi	r25, 0x0F	; 15
     72a:	01 97       	sbiw	r24, 0x01	; 1
     72c:	f1 f7       	brne	.-4      	; 0x72a <LCD_Init+0x40>
     72e:	00 c0       	rjmp	.+0      	; 0x730 <LCD_Init+0x46>
     730:	00 00       	nop
    
   _delay_ms(1);


    LCD_WriteCommand (FUNCTION_SET);
     732:	88 e2       	ldi	r24, 0x28	; 40
     734:	0e 94 f6 02 	call	0x5ec	; 0x5ec <LCD_WriteCommand>
     738:	8f e9       	ldi	r24, 0x9F	; 159
     73a:	9f e0       	ldi	r25, 0x0F	; 15
     73c:	01 97       	sbiw	r24, 0x01	; 1
     73e:	f1 f7       	brne	.-4      	; 0x73c <LCD_Init+0x52>
     740:	00 c0       	rjmp	.+0      	; 0x742 <LCD_Init+0x58>
     742:	00 00       	nop
    _delay_ms(1);
    LCD_WriteCommand (CLEAR_DISPLAY); 
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	0e 94 f6 02 	call	0x5ec	; 0x5ec <LCD_WriteCommand>
     74a:	8f e9       	ldi	r24, 0x9F	; 159
     74c:	9f e0       	ldi	r25, 0x0F	; 15
     74e:	01 97       	sbiw	r24, 0x01	; 1
     750:	f1 f7       	brne	.-4      	; 0x74e <LCD_Init+0x64>
     752:	00 c0       	rjmp	.+0      	; 0x754 <LCD_Init+0x6a>
     754:	00 00       	nop
    _delay_ms(1);
    LCD_WriteCommand (DISPLAY_ON_CURSOR_BLINKING); 
     756:	8f e0       	ldi	r24, 0x0F	; 15
     758:	0e 94 f6 02 	call	0x5ec	; 0x5ec <LCD_WriteCommand>
     75c:	8f e9       	ldi	r24, 0x9F	; 159
     75e:	9f e0       	ldi	r25, 0x0F	; 15
     760:	01 97       	sbiw	r24, 0x01	; 1
     762:	f1 f7       	brne	.-4      	; 0x760 <LCD_Init+0x76>
     764:	00 c0       	rjmp	.+0      	; 0x766 <LCD_Init+0x7c>
     766:	00 00       	nop
     768:	08 95       	ret

0000076a <LCD_WriteChar>:
    
    _delay_ms(5); /*LCD store delay*/
}

void LCD_WriteChar(u8 chr)
{  
     76a:	cf 93       	push	r28
     76c:	c8 2f       	mov	r28, r24
    /*
    RS (Register Select)
    RS = 1 -> Data Register is selected
    */
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_RS_PIN ,DIO_PIN_HIGH);
     76e:	41 e0       	ldi	r20, 0x01	; 1
     770:	63 e0       	ldi	r22, 0x03	; 3
     772:	80 e0       	ldi	r24, 0x00	; 0
     774:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     778:	8f e9       	ldi	r24, 0x9F	; 159
     77a:	9f e0       	ldi	r25, 0x0F	; 15
     77c:	01 97       	sbiw	r24, 0x01	; 1
     77e:	f1 f7       	brne	.-4      	; 0x77c <LCD_WriteChar+0x12>
     780:	00 c0       	rjmp	.+0      	; 0x782 <LCD_WriteChar+0x18>
     782:	00 00       	nop
    _delay_ms(1);

    
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D4 , GET_BIT(chr,4));
     784:	c4 fb       	bst	r28, 4
     786:	44 27       	eor	r20, r20
     788:	40 f9       	bld	r20, 0
     78a:	60 e0       	ldi	r22, 0x00	; 0
     78c:	81 e0       	ldi	r24, 0x01	; 1
     78e:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D5 , GET_BIT(chr,5));
     792:	c5 fb       	bst	r28, 5
     794:	44 27       	eor	r20, r20
     796:	40 f9       	bld	r20, 0
     798:	61 e0       	ldi	r22, 0x01	; 1
     79a:	81 e0       	ldi	r24, 0x01	; 1
     79c:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D6 , GET_BIT(chr,6));
     7a0:	c6 fb       	bst	r28, 6
     7a2:	44 27       	eor	r20, r20
     7a4:	40 f9       	bld	r20, 0
     7a6:	62 e0       	ldi	r22, 0x02	; 2
     7a8:	81 e0       	ldi	r24, 0x01	; 1
     7aa:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D7 , GET_BIT(chr,7));
     7ae:	4c 2f       	mov	r20, r28
     7b0:	44 1f       	adc	r20, r20
     7b2:	44 27       	eor	r20, r20
     7b4:	44 1f       	adc	r20, r20
     7b6:	64 e0       	ldi	r22, 0x04	; 4
     7b8:	81 e0       	ldi	r24, 0x01	; 1
     7ba:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     7be:	8f e9       	ldi	r24, 0x9F	; 159
     7c0:	9f e0       	ldi	r25, 0x0F	; 15
     7c2:	01 97       	sbiw	r24, 0x01	; 1
     7c4:	f1 f7       	brne	.-4      	; 0x7c2 <LCD_WriteChar+0x58>
     7c6:	00 c0       	rjmp	.+0      	; 0x7c8 <LCD_WriteChar+0x5e>
     7c8:	00 00       	nop
    
    
    /*
    Falling Edge to process the data
    */
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_EN_PIN ,DIO_PIN_HIGH);
     7ca:	41 e0       	ldi	r20, 0x01	; 1
     7cc:	62 e0       	ldi	r22, 0x02	; 2
     7ce:	80 e0       	ldi	r24, 0x00	; 0
     7d0:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     7d4:	8f e9       	ldi	r24, 0x9F	; 159
     7d6:	9f e0       	ldi	r25, 0x0F	; 15
     7d8:	01 97       	sbiw	r24, 0x01	; 1
     7da:	f1 f7       	brne	.-4      	; 0x7d8 <LCD_WriteChar+0x6e>
     7dc:	00 c0       	rjmp	.+0      	; 0x7de <LCD_WriteChar+0x74>
     7de:	00 00       	nop
    _delay_ms(1);
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_EN_PIN ,DIO_PIN_LOW);     
     7e0:	40 e0       	ldi	r20, 0x00	; 0
     7e2:	62 e0       	ldi	r22, 0x02	; 2
     7e4:	80 e0       	ldi	r24, 0x00	; 0
     7e6:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     7ea:	8f e9       	ldi	r24, 0x9F	; 159
     7ec:	9f e0       	ldi	r25, 0x0F	; 15
     7ee:	01 97       	sbiw	r24, 0x01	; 1
     7f0:	f1 f7       	brne	.-4      	; 0x7ee <LCD_WriteChar+0x84>
     7f2:	00 c0       	rjmp	.+0      	; 0x7f4 <LCD_WriteChar+0x8a>
     7f4:	00 00       	nop
    _delay_ms(1);


    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D4 , GET_BIT(chr,0));
     7f6:	4c 2f       	mov	r20, r28
     7f8:	41 70       	andi	r20, 0x01	; 1
     7fa:	60 e0       	ldi	r22, 0x00	; 0
     7fc:	81 e0       	ldi	r24, 0x01	; 1
     7fe:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D5 , GET_BIT(chr,1));
     802:	c1 fb       	bst	r28, 1
     804:	44 27       	eor	r20, r20
     806:	40 f9       	bld	r20, 0
     808:	61 e0       	ldi	r22, 0x01	; 1
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D6 , GET_BIT(chr,2));
     810:	c2 fb       	bst	r28, 2
     812:	44 27       	eor	r20, r20
     814:	40 f9       	bld	r20, 0
     816:	62 e0       	ldi	r22, 0x02	; 2
     818:	81 e0       	ldi	r24, 0x01	; 1
     81a:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
    DIO_SetPinValue (LCD_4BIT_DATA_PORT, LCD_D7 , GET_BIT(chr,3));
     81e:	c3 fb       	bst	r28, 3
     820:	44 27       	eor	r20, r20
     822:	40 f9       	bld	r20, 0
     824:	64 e0       	ldi	r22, 0x04	; 4
     826:	81 e0       	ldi	r24, 0x01	; 1
     828:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     82c:	8f e9       	ldi	r24, 0x9F	; 159
     82e:	9f e0       	ldi	r25, 0x0F	; 15
     830:	01 97       	sbiw	r24, 0x01	; 1
     832:	f1 f7       	brne	.-4      	; 0x830 <__DATA_REGION_LENGTH__+0x30>
     834:	00 c0       	rjmp	.+0      	; 0x836 <__DATA_REGION_LENGTH__+0x36>
     836:	00 00       	nop
    _delay_ms(1);
    
    /*
    Falling Edge to process the data
    */
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_EN_PIN ,DIO_PIN_HIGH);     /*Enable=1*/
     838:	41 e0       	ldi	r20, 0x01	; 1
     83a:	62 e0       	ldi	r22, 0x02	; 2
     83c:	80 e0       	ldi	r24, 0x00	; 0
     83e:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     842:	8f e9       	ldi	r24, 0x9F	; 159
     844:	9f e0       	ldi	r25, 0x0F	; 15
     846:	01 97       	sbiw	r24, 0x01	; 1
     848:	f1 f7       	brne	.-4      	; 0x846 <__DATA_REGION_LENGTH__+0x46>
     84a:	00 c0       	rjmp	.+0      	; 0x84c <__DATA_REGION_LENGTH__+0x4c>
     84c:	00 00       	nop
    _delay_ms(1);
    DIO_SetPinValue(LCD_4BIT_CMD_PORT ,LCD_EN_PIN ,DIO_PIN_LOW);
     84e:	40 e0       	ldi	r20, 0x00	; 0
     850:	62 e0       	ldi	r22, 0x02	; 2
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	0e 94 57 01 	call	0x2ae	; 0x2ae <DIO_SetPinValue>
     858:	8f e1       	ldi	r24, 0x1F	; 31
     85a:	9e e4       	ldi	r25, 0x4E	; 78
     85c:	01 97       	sbiw	r24, 0x01	; 1
     85e:	f1 f7       	brne	.-4      	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
     860:	00 c0       	rjmp	.+0      	; 0x862 <__stack+0x3>
     862:	00 00       	nop
    
    _delay_ms(5); /* LCD store delay*/
}
     864:	cf 91       	pop	r28
     866:	08 95       	ret

00000868 <LCD_WriteString>:

LCD_errors_status LCD_WriteString(char* str)
{
     868:	0f 93       	push	r16
     86a:	1f 93       	push	r17
     86c:	cf 93       	push	r28
     86e:	8c 01       	movw	r16, r24
	
    uint8_t i = 0;
     870:	c0 e0       	ldi	r28, 0x00	; 0
    
    while(str[i] != '\0')
     872:	05 c0       	rjmp	.+10     	; 0x87e <LCD_WriteString+0x16>
    {
        LCD_WriteChar(str[i]);
     874:	0e 94 b5 03 	call	0x76a	; 0x76a <LCD_WriteChar>
        i++;
     878:	cf 5f       	subi	r28, 0xFF	; 255
		if(i>LCD_WIDTH)
     87a:	c5 31       	cpi	r28, 0x15	; 21
     87c:	38 f4       	brcc	.+14     	; 0x88c <LCD_WriteString+0x24>
LCD_errors_status LCD_WriteString(char* str)
{
	
    uint8_t i = 0;
    
    while(str[i] != '\0')
     87e:	f8 01       	movw	r30, r16
     880:	ec 0f       	add	r30, r28
     882:	f1 1d       	adc	r31, r1
     884:	80 81       	ld	r24, Z
     886:	81 11       	cpse	r24, r1
     888:	f5 cf       	rjmp	.-22     	; 0x874 <LCD_WriteString+0xc>
     88a:	01 c0       	rjmp	.+2      	; 0x88e <LCD_WriteString+0x26>
    {
        LCD_WriteChar(str[i]);
        i++;
		if(i>LCD_WIDTH)
			return LCD_MAX_SIZE_REACHED_ERROR;
     88c:	81 e0       	ldi	r24, 0x01	; 1
    }
	return LCD_no_error;
}
     88e:	cf 91       	pop	r28
     890:	1f 91       	pop	r17
     892:	0f 91       	pop	r16
     894:	08 95       	ret

00000896 <LCD_Goto>:


LCD_errors_status LCD_Goto(u8 row, u8 col)
{
     896:	cf 93       	push	r28
     898:	df 93       	push	r29
     89a:	00 d0       	rcall	.+0      	; 0x89c <LCD_Goto+0x6>
     89c:	00 d0       	rcall	.+0      	; 0x89e <LCD_Goto+0x8>
     89e:	cd b7       	in	r28, 0x3d	; 61
     8a0:	de b7       	in	r29, 0x3e	; 62
	
	if(row>MAX_NUMBER_OF_ROWS)
     8a2:	85 30       	cpi	r24, 0x05	; 5
     8a4:	b0 f4       	brcc	.+44     	; 0x8d2 <LCD_Goto+0x3c>
		return LCD_MAX_ROW_SIZE_EXCEEDED;
		
	else if (col>LCD_WIDTH)
     8a6:	65 31       	cpi	r22, 0x15	; 21
     8a8:	b0 f4       	brcc	.+44     	; 0x8d6 <LCD_Goto+0x40>
		return LCD_MAX_COLUMN_SIZE_EXCEEDED;
	
	
	u8 pos[] = { 0x80, 0xC0, 0x94, 0xD4};
     8aa:	90 e8       	ldi	r25, 0x80	; 128
     8ac:	99 83       	std	Y+1, r25	; 0x01
     8ae:	90 ec       	ldi	r25, 0xC0	; 192
     8b0:	9a 83       	std	Y+2, r25	; 0x02
     8b2:	94 e9       	ldi	r25, 0x94	; 148
     8b4:	9b 83       	std	Y+3, r25	; 0x03
     8b6:	94 ed       	ldi	r25, 0xD4	; 212
     8b8:	9c 83       	std	Y+4, r25	; 0x04
	LCD_WriteCommand(pos[row]+col);
     8ba:	e1 e0       	ldi	r30, 0x01	; 1
     8bc:	f0 e0       	ldi	r31, 0x00	; 0
     8be:	ec 0f       	add	r30, r28
     8c0:	fd 1f       	adc	r31, r29
     8c2:	e8 0f       	add	r30, r24
     8c4:	f1 1d       	adc	r31, r1
     8c6:	80 81       	ld	r24, Z
     8c8:	86 0f       	add	r24, r22
     8ca:	0e 94 f6 02 	call	0x5ec	; 0x5ec <LCD_WriteCommand>
	
	return LCD_no_error;
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	03 c0       	rjmp	.+6      	; 0x8d8 <LCD_Goto+0x42>

LCD_errors_status LCD_Goto(u8 row, u8 col)
{
	
	if(row>MAX_NUMBER_OF_ROWS)
		return LCD_MAX_ROW_SIZE_EXCEEDED;
     8d2:	82 e0       	ldi	r24, 0x02	; 2
     8d4:	01 c0       	rjmp	.+2      	; 0x8d8 <LCD_Goto+0x42>
		
	else if (col>LCD_WIDTH)
		return LCD_MAX_COLUMN_SIZE_EXCEEDED;
     8d6:	83 e0       	ldi	r24, 0x03	; 3
	u8 pos[] = { 0x80, 0xC0, 0x94, 0xD4};
	LCD_WriteCommand(pos[row]+col);
	
	return LCD_no_error;

}
     8d8:	0f 90       	pop	r0
     8da:	0f 90       	pop	r0
     8dc:	0f 90       	pop	r0
     8de:	0f 90       	pop	r0
     8e0:	df 91       	pop	r29
     8e2:	cf 91       	pop	r28
     8e4:	08 95       	ret

000008e6 <LCD_Clear>:

void LCD_Clear(void)
{
    LCD_WriteCommand(0x01);
     8e6:	81 e0       	ldi	r24, 0x01	; 1
     8e8:	0e 94 f6 02 	call	0x5ec	; 0x5ec <LCD_WriteCommand>
     8ec:	08 95       	ret

000008ee <LCD_WriteNumber>:
}

void LCD_WriteNumber( u32 num)
{
     8ee:	1f 93       	push	r17
     8f0:	cf 93       	push	r28
     8f2:	df 93       	push	r29
     8f4:	cd b7       	in	r28, 0x3d	; 61
     8f6:	de b7       	in	r29, 0x3e	; 62
     8f8:	2a 97       	sbiw	r28, 0x0a	; 10
     8fa:	0f b6       	in	r0, 0x3f	; 63
     8fc:	f8 94       	cli
     8fe:	de bf       	out	0x3e, r29	; 62
     900:	0f be       	out	0x3f, r0	; 63
     902:	cd bf       	out	0x3d, r28	; 61
	u8 str[10],i=0,j;
	if (num==0)
     904:	61 15       	cp	r22, r1
     906:	71 05       	cpc	r23, r1
     908:	81 05       	cpc	r24, r1
     90a:	91 05       	cpc	r25, r1
     90c:	c1 f4       	brne	.+48     	; 0x93e <LCD_WriteNumber+0x50>
	{
		LCD_WriteChar('0');
     90e:	80 e3       	ldi	r24, 0x30	; 48
     910:	0e 94 b5 03 	call	0x76a	; 0x76a <LCD_WriteChar>
     914:	2a c0       	rjmp	.+84     	; 0x96a <LCD_WriteNumber+0x7c>
		LCD_WriteChar('-');
	}
	
	while(num)
	{
		str[i]=num%10 +'0';
     916:	2a e0       	ldi	r18, 0x0A	; 10
     918:	30 e0       	ldi	r19, 0x00	; 0
     91a:	40 e0       	ldi	r20, 0x00	; 0
     91c:	50 e0       	ldi	r21, 0x00	; 0
     91e:	0e 94 a7 09 	call	0x134e	; 0x134e <__udivmodsi4>
     922:	e1 e0       	ldi	r30, 0x01	; 1
     924:	f0 e0       	ldi	r31, 0x00	; 0
     926:	ec 0f       	add	r30, r28
     928:	fd 1f       	adc	r31, r29
     92a:	e1 0f       	add	r30, r17
     92c:	f1 1d       	adc	r31, r1
     92e:	60 5d       	subi	r22, 0xD0	; 208
     930:	60 83       	st	Z, r22
		i++;
     932:	1f 5f       	subi	r17, 0xFF	; 255
		num=num/10;
     934:	62 2f       	mov	r22, r18
     936:	73 2f       	mov	r23, r19
     938:	84 2f       	mov	r24, r20
     93a:	95 2f       	mov	r25, r21
     93c:	01 c0       	rjmp	.+2      	; 0x940 <LCD_WriteNumber+0x52>
     93e:	10 e0       	ldi	r17, 0x00	; 0
	{
		num=num*(-1);
		LCD_WriteChar('-');
	}
	
	while(num)
     940:	61 15       	cp	r22, r1
     942:	71 05       	cpc	r23, r1
     944:	81 05       	cpc	r24, r1
     946:	91 05       	cpc	r25, r1
     948:	31 f7       	brne	.-52     	; 0x916 <LCD_WriteNumber+0x28>
     94a:	0d c0       	rjmp	.+26     	; 0x966 <LCD_WriteNumber+0x78>
		i++;
		num=num/10;
	}
	for (j=i;j>0;j--)
	{
		LCD_WriteChar(str[j-1]);
     94c:	e1 2f       	mov	r30, r17
     94e:	f0 e0       	ldi	r31, 0x00	; 0
     950:	31 97       	sbiw	r30, 0x01	; 1
     952:	81 e0       	ldi	r24, 0x01	; 1
     954:	90 e0       	ldi	r25, 0x00	; 0
     956:	8c 0f       	add	r24, r28
     958:	9d 1f       	adc	r25, r29
     95a:	e8 0f       	add	r30, r24
     95c:	f9 1f       	adc	r31, r25
     95e:	80 81       	ld	r24, Z
     960:	0e 94 b5 03 	call	0x76a	; 0x76a <LCD_WriteChar>
	{
		str[i]=num%10 +'0';
		i++;
		num=num/10;
	}
	for (j=i;j>0;j--)
     964:	11 50       	subi	r17, 0x01	; 1
     966:	11 11       	cpse	r17, r1
     968:	f1 cf       	rjmp	.-30     	; 0x94c <LCD_WriteNumber+0x5e>
	{
		LCD_WriteChar(str[j-1]);
	}

}
     96a:	2a 96       	adiw	r28, 0x0a	; 10
     96c:	0f b6       	in	r0, 0x3f	; 63
     96e:	f8 94       	cli
     970:	de bf       	out	0x3e, r29	; 62
     972:	0f be       	out	0x3f, r0	; 63
     974:	cd bf       	out	0x3d, r28	; 61
     976:	df 91       	pop	r29
     978:	cf 91       	pop	r28
     97a:	1f 91       	pop	r17
     97c:	08 95       	ret

0000097e <main>:

#include "sunrise_alarm.h"
extern u16 Adc_Data;
int main(void)
{
   Init();
     97e:	0e 94 33 08 	call	0x1066	; 0x1066 <Init>
   
while (1)
{
	
	runnable();
     982:	0e 94 c5 07 	call	0xf8a	; 0xf8a <runnable>
     986:	fd cf       	rjmp	.-6      	; 0x982 <main+0x4>

00000988 <count_time>:
        }
    }

    void count_time()
    {
        ticks++;
     988:	80 91 b2 01 	lds	r24, 0x01B2	; 0x8001b2 <ticks>
     98c:	90 91 b3 01 	lds	r25, 0x01B3	; 0x8001b3 <ticks+0x1>
     990:	01 96       	adiw	r24, 0x01	; 1
     992:	90 93 b3 01 	sts	0x01B3, r25	; 0x8001b3 <ticks+0x1>
     996:	80 93 b2 01 	sts	0x01B2, r24	; 0x8001b2 <ticks>
        if (ticks>61)
     99a:	80 91 b2 01 	lds	r24, 0x01B2	; 0x8001b2 <ticks>
     99e:	90 91 b3 01 	lds	r25, 0x01B3	; 0x8001b3 <ticks+0x1>
     9a2:	ce 97       	sbiw	r24, 0x3e	; 62
     9a4:	78 f0       	brcs	.+30     	; 0x9c4 <count_time+0x3c>
        {
            seconds++;
     9a6:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <seconds>
     9aa:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <seconds+0x1>
     9ae:	01 96       	adiw	r24, 0x01	; 1
     9b0:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <seconds+0x1>
     9b4:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <seconds>
            TCNT2=246;
     9b8:	86 ef       	ldi	r24, 0xF6	; 246
     9ba:	84 bd       	out	0x24, r24	; 36
            ticks =0;
     9bc:	10 92 b3 01 	sts	0x01B3, r1	; 0x8001b3 <ticks+0x1>
     9c0:	10 92 b2 01 	sts	0x01B2, r1	; 0x8001b2 <ticks>
        }
        if (seconds>59)
     9c4:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <seconds>
     9c8:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <seconds+0x1>
     9cc:	cc 97       	sbiw	r24, 0x3c	; 60
     9ce:	68 f0       	brcs	.+26     	; 0x9ea <count_time+0x62>
        {
            minutes++;
     9d0:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <__data_end>
     9d4:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <__data_end+0x1>
     9d8:	01 96       	adiw	r24, 0x01	; 1
     9da:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <__data_end+0x1>
     9de:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <__data_end>
            seconds=0;
     9e2:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <seconds+0x1>
     9e6:	10 92 a4 01 	sts	0x01A4, r1	; 0x8001a4 <seconds>
     9ea:	08 95       	ret

000009ec <sorting_timers>:
    match_status matching=NO_MATCH;
	
	st_timer0_config_t_ timer0_config;

    void sorting_timers(alarm* INPUT_TIMERS)
    {
     9ec:	cf 92       	push	r12
     9ee:	df 92       	push	r13
     9f0:	ef 92       	push	r14
     9f2:	ff 92       	push	r15
     9f4:	0f 93       	push	r16
     9f6:	1f 93       	push	r17
     9f8:	cf 93       	push	r28
     9fa:	df 93       	push	r29
     9fc:	bc 01       	movw	r22, r24
        alarm temp;

        for(int k=0; k<last_timer; k++)
     9fe:	c0 e0       	ldi	r28, 0x00	; 0
     a00:	d0 e0       	ldi	r29, 0x00	; 0
     a02:	51 c0       	rjmp	.+162    	; 0xaa6 <sorting_timers+0xba>
        {
            for(int l=0; l<last_timer-k; l++)
            {
                if(INPUT_TIMERS[l].minutes_relative<INPUT_TIMERS[l+1].minutes_relative)
     a04:	da 01       	movw	r26, r20
     a06:	aa 0f       	add	r26, r26
     a08:	bb 1f       	adc	r27, r27
     a0a:	aa 0f       	add	r26, r26
     a0c:	bb 1f       	adc	r27, r27
     a0e:	a6 0f       	add	r26, r22
     a10:	b7 1f       	adc	r27, r23
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8c 91       	ld	r24, X
     a16:	12 97       	sbiw	r26, 0x02	; 2
     a18:	fa 01       	movw	r30, r20
     a1a:	31 96       	adiw	r30, 0x01	; 1
     a1c:	ee 0f       	add	r30, r30
     a1e:	ff 1f       	adc	r31, r31
     a20:	ee 0f       	add	r30, r30
     a22:	ff 1f       	adc	r31, r31
     a24:	e6 0f       	add	r30, r22
     a26:	f7 1f       	adc	r31, r23
     a28:	92 81       	ldd	r25, Z+2	; 0x02
     a2a:	89 17       	cp	r24, r25
     a2c:	9c f4       	brge	.+38     	; 0xa54 <sorting_timers+0x68>
                {
                    temp= INPUT_TIMERS[l];
     a2e:	0d 91       	ld	r16, X+
     a30:	1d 91       	ld	r17, X+
     a32:	2d 91       	ld	r18, X+
     a34:	3c 91       	ld	r19, X
     a36:	13 97       	sbiw	r26, 0x03	; 3
                    INPUT_TIMERS[l]=INPUT_TIMERS[l+1];
     a38:	c0 80       	ld	r12, Z
     a3a:	d1 80       	ldd	r13, Z+1	; 0x01
     a3c:	e2 80       	ldd	r14, Z+2	; 0x02
     a3e:	f3 80       	ldd	r15, Z+3	; 0x03
     a40:	cd 92       	st	X+, r12
     a42:	dd 92       	st	X+, r13
     a44:	ed 92       	st	X+, r14
     a46:	fc 92       	st	X, r15
     a48:	13 97       	sbiw	r26, 0x03	; 3
                    INPUT_TIMERS[l+1]=temp;
     a4a:	00 83       	st	Z, r16
     a4c:	11 83       	std	Z+1, r17	; 0x01
     a4e:	22 83       	std	Z+2, r18	; 0x02
     a50:	33 83       	std	Z+3, r19	; 0x03
     a52:	1a c0       	rjmp	.+52     	; 0xa88 <sorting_timers+0x9c>
                }
                else if(INPUT_TIMERS[l].minutes_relative==INPUT_TIMERS[l+1].minutes_relative)
     a54:	89 13       	cpse	r24, r25
     a56:	18 c0       	rjmp	.+48     	; 0xa88 <sorting_timers+0x9c>
                {
                    if(INPUT_TIMERS[l].seconds_relative<INPUT_TIMERS[l+1].seconds_relative)
     a58:	13 96       	adiw	r26, 0x03	; 3
     a5a:	9c 91       	ld	r25, X
     a5c:	13 97       	sbiw	r26, 0x03	; 3
     a5e:	83 81       	ldd	r24, Z+3	; 0x03
     a60:	98 17       	cp	r25, r24
     a62:	94 f4       	brge	.+36     	; 0xa88 <sorting_timers+0x9c>
                    {
                        temp= INPUT_TIMERS[l];
     a64:	0d 91       	ld	r16, X+
     a66:	1d 91       	ld	r17, X+
     a68:	2d 91       	ld	r18, X+
     a6a:	3c 91       	ld	r19, X
     a6c:	13 97       	sbiw	r26, 0x03	; 3
                        INPUT_TIMERS[l]=INPUT_TIMERS[l+1];
     a6e:	c0 80       	ld	r12, Z
     a70:	d1 80       	ldd	r13, Z+1	; 0x01
     a72:	e2 80       	ldd	r14, Z+2	; 0x02
     a74:	f3 80       	ldd	r15, Z+3	; 0x03
     a76:	cd 92       	st	X+, r12
     a78:	dd 92       	st	X+, r13
     a7a:	ed 92       	st	X+, r14
     a7c:	fc 92       	st	X, r15
     a7e:	13 97       	sbiw	r26, 0x03	; 3
                        INPUT_TIMERS[l+1]=temp;
     a80:	00 83       	st	Z, r16
     a82:	11 83       	std	Z+1, r17	; 0x01
     a84:	22 83       	std	Z+2, r18	; 0x02
     a86:	33 83       	std	Z+3, r19	; 0x03
    {
        alarm temp;

        for(int k=0; k<last_timer; k++)
        {
            for(int l=0; l<last_timer-k; l++)
     a88:	4f 5f       	subi	r20, 0xFF	; 255
     a8a:	5f 4f       	sbci	r21, 0xFF	; 255
     a8c:	02 c0       	rjmp	.+4      	; 0xa92 <sorting_timers+0xa6>
     a8e:	40 e0       	ldi	r20, 0x00	; 0
     a90:	50 e0       	ldi	r21, 0x00	; 0
     a92:	20 91 b4 01 	lds	r18, 0x01B4	; 0x8001b4 <last_timer>
     a96:	30 e0       	ldi	r19, 0x00	; 0
     a98:	2c 1b       	sub	r18, r28
     a9a:	3d 0b       	sbc	r19, r29
     a9c:	42 17       	cp	r20, r18
     a9e:	53 07       	cpc	r21, r19
     aa0:	0c f4       	brge	.+2      	; 0xaa4 <sorting_timers+0xb8>
     aa2:	b0 cf       	rjmp	.-160    	; 0xa04 <sorting_timers+0x18>

    void sorting_timers(alarm* INPUT_TIMERS)
    {
        alarm temp;

        for(int k=0; k<last_timer; k++)
     aa4:	21 96       	adiw	r28, 0x01	; 1
     aa6:	80 91 b4 01 	lds	r24, 0x01B4	; 0x8001b4 <last_timer>
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	c8 17       	cp	r28, r24
     aae:	d9 07       	cpc	r29, r25
     ab0:	74 f3       	brlt	.-36     	; 0xa8e <sorting_timers+0xa2>
                        INPUT_TIMERS[l+1]=temp;
                    }
                }
            }
        }
    }
     ab2:	df 91       	pop	r29
     ab4:	cf 91       	pop	r28
     ab6:	1f 91       	pop	r17
     ab8:	0f 91       	pop	r16
     aba:	ff 90       	pop	r15
     abc:	ef 90       	pop	r14
     abe:	df 90       	pop	r13
     ac0:	cf 90       	pop	r12
     ac2:	08 95       	ret

00000ac4 <SET>:

    error_status SET(void)
    {
     ac4:	0f 93       	push	r16
     ac6:	1f 93       	push	r17
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	cd b7       	in	r28, 0x3d	; 61
     ace:	de b7       	in	r29, 0x3e	; 62
     ad0:	28 97       	sbiw	r28, 0x08	; 8
     ad2:	0f b6       	in	r0, 0x3f	; 63
     ad4:	f8 94       	cli
     ad6:	de bf       	out	0x3e, r29	; 62
     ad8:	0f be       	out	0x3f, r0	; 63
     ada:	cd bf       	out	0x3d, r28	; 61
        uint8_t array_section[2]= {0};
     adc:	1a 82       	std	Y+2, r1	; 0x02
     ade:	19 82       	std	Y+1, r1	; 0x01
        char input_string[6]= {0};
     ae0:	fe 01       	movw	r30, r28
     ae2:	33 96       	adiw	r30, 0x03	; 3
     ae4:	86 e0       	ldi	r24, 0x06	; 6
     ae6:	df 01       	movw	r26, r30
     ae8:	1d 92       	st	X+, r1
     aea:	8a 95       	dec	r24
     aec:	e9 f7       	brne	.-6      	; 0xae8 <SET+0x24>

        input_string[5]='\0';
        if(last_timer>=3)
     aee:	80 91 b4 01 	lds	r24, 0x01B4	; 0x8001b4 <last_timer>
     af2:	83 30       	cpi	r24, 0x03	; 3
     af4:	40 f0       	brcs	.+16     	; 0xb06 <SET+0x42>
        {
            LCD_Clear();
     af6:	0e 94 73 04 	call	0x8e6	; 0x8e6 <LCD_Clear>
            LCD_WriteString("timers full");
     afa:	87 e8       	ldi	r24, 0x87	; 135
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
            return ERROR;
     b02:	80 e0       	ldi	r24, 0x00	; 0
     b04:	b3 c0       	rjmp	.+358    	; 0xc6c <SET+0x1a8>
        }
        uint8_t i=0;
        LCD_Goto(0,0);
     b06:	60 e0       	ldi	r22, 0x00	; 0
     b08:	80 e0       	ldi	r24, 0x00	; 0
     b0a:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("Enter alarm time :");
     b0e:	83 e9       	ldi	r24, 0x93	; 147
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        LCD_Goto(1,7);
     b16:	67 e0       	ldi	r22, 0x07	; 7
     b18:	81 e0       	ldi	r24, 0x01	; 1
     b1a:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("00:00");
     b1e:	86 ea       	ldi	r24, 0xA6	; 166
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        LCD_Goto(1,7);
     b26:	67 e0       	ldi	r22, 0x07	; 7
     b28:	81 e0       	ldi	r24, 0x01	; 1
     b2a:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        char Pressed_Key=key;
     b2e:	00 91 60 00 	lds	r16, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
        {
            LCD_Clear();
            LCD_WriteString("timers full");
            return ERROR;
        }
        uint8_t i=0;
     b32:	10 e0       	ldi	r17, 0x00	; 0
        LCD_Goto(1,7);
        LCD_WriteString("00:00");
        LCD_Goto(1,7);
        char Pressed_Key=key;

        while(Pressed_Key != '=')
     b34:	1e c0       	rjmp	.+60     	; 0xb72 <SET+0xae>
        {
            
            while(KeyPad_GetValue()!=PRESSED);
     b36:	0e 94 8c 02 	call	0x518	; 0x518 <KeyPad_GetValue>
     b3a:	81 11       	cpse	r24, r1
     b3c:	fc cf       	rjmp	.-8      	; 0xb36 <SET+0x72>

			Pressed_Key=key;
     b3e:	00 91 60 00 	lds	r16, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
            input_string[i]=Pressed_Key;
     b42:	e3 e0       	ldi	r30, 0x03	; 3
     b44:	f0 e0       	ldi	r31, 0x00	; 0
     b46:	ec 0f       	add	r30, r28
     b48:	fd 1f       	adc	r31, r29
     b4a:	e1 0f       	add	r30, r17
     b4c:	f1 1d       	adc	r31, r1
     b4e:	00 83       	st	Z, r16

            LCD_WriteChar(Pressed_Key);
     b50:	80 2f       	mov	r24, r16
     b52:	0e 94 b5 03 	call	0x76a	; 0x76a <LCD_WriteChar>
            i++;
     b56:	1f 5f       	subi	r17, 0xFF	; 255
            if(i==2)
     b58:	12 30       	cpi	r17, 0x02	; 2
     b5a:	21 f4       	brne	.+8      	; 0xb64 <SET+0xa0>
                LCD_Goto(1,10);
     b5c:	6a e0       	ldi	r22, 0x0A	; 10
     b5e:	81 e0       	ldi	r24, 0x01	; 1
     b60:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
            if(i>4)
     b64:	15 30       	cpi	r17, 0x05	; 5
     b66:	28 f0       	brcs	.+10     	; 0xb72 <SET+0xae>
            {
                i=0;
                LCD_Goto(1,7);
     b68:	67 e0       	ldi	r22, 0x07	; 7
     b6a:	81 e0       	ldi	r24, 0x01	; 1
     b6c:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
            i++;
            if(i==2)
                LCD_Goto(1,10);
            if(i>4)
            {
                i=0;
     b70:	10 e0       	ldi	r17, 0x00	; 0
        LCD_Goto(1,7);
        LCD_WriteString("00:00");
        LCD_Goto(1,7);
        char Pressed_Key=key;

        while(Pressed_Key != '=')
     b72:	0d 33       	cpi	r16, 0x3D	; 61
     b74:	01 f7       	brne	.-64     	; 0xb36 <SET+0x72>
            {
                i=0;
                LCD_Goto(1,7);
            }
        }
        array_section[0]=input_string[0];
     b76:	8b 81       	ldd	r24, Y+3	; 0x03
     b78:	89 83       	std	Y+1, r24	; 0x01
        array_section[1]=input_string[1];
     b7a:	8c 81       	ldd	r24, Y+4	; 0x04
     b7c:	8a 83       	std	Y+2, r24	; 0x02
        if(atoi(array_section)>=0 && atoi(array_section)<60)
     b7e:	ce 01       	movw	r24, r28
     b80:	01 96       	adiw	r24, 0x01	; 1
     b82:	0e 94 c9 09 	call	0x1392	; 0x1392 <atoi>
     b86:	99 23       	and	r25, r25
     b88:	04 f1       	brlt	.+64     	; 0xbca <SET+0x106>
     b8a:	ce 01       	movw	r24, r28
     b8c:	01 96       	adiw	r24, 0x01	; 1
     b8e:	0e 94 c9 09 	call	0x1392	; 0x1392 <atoi>
     b92:	cc 97       	sbiw	r24, 0x3c	; 60
     b94:	d4 f4       	brge	.+52     	; 0xbca <SET+0x106>
            INPUT_TIMERS[last_timer].minutes_user=atoi(array_section);
     b96:	00 91 b4 01 	lds	r16, 0x01B4	; 0x8001b4 <last_timer>
     b9a:	10 e0       	ldi	r17, 0x00	; 0
     b9c:	ce 01       	movw	r24, r28
     b9e:	01 96       	adiw	r24, 0x01	; 1
     ba0:	0e 94 c9 09 	call	0x1392	; 0x1392 <atoi>
     ba4:	00 0f       	add	r16, r16
     ba6:	11 1f       	adc	r17, r17
     ba8:	00 0f       	add	r16, r16
     baa:	11 1f       	adc	r17, r17
     bac:	f8 01       	movw	r30, r16
     bae:	ed 59       	subi	r30, 0x9D	; 157
     bb0:	ff 4f       	sbci	r31, 0xFF	; 255
     bb2:	81 83       	std	Z+1, r24	; 0x01
        {
            LCD_Goto(3,0);
            LCD_WriteString("invalid");
            return ERROR;
        }
        array_section[0]=input_string[2];
     bb4:	8d 81       	ldd	r24, Y+5	; 0x05
     bb6:	89 83       	std	Y+1, r24	; 0x01
        array_section[1]=input_string[3];
     bb8:	8e 81       	ldd	r24, Y+6	; 0x06
     bba:	8a 83       	std	Y+2, r24	; 0x02

        if(atoi(array_section)>=0 && atoi(array_section)<60)
     bbc:	ce 01       	movw	r24, r28
     bbe:	01 96       	adiw	r24, 0x01	; 1
     bc0:	0e 94 c9 09 	call	0x1392	; 0x1392 <atoi>
     bc4:	99 23       	and	r25, r25
     bc6:	5c f4       	brge	.+22     	; 0xbde <SET+0x11a>
     bc8:	48 c0       	rjmp	.+144    	; 0xc5a <SET+0x196>
        array_section[1]=input_string[1];
        if(atoi(array_section)>=0 && atoi(array_section)<60)
            INPUT_TIMERS[last_timer].minutes_user=atoi(array_section);
        else
        {
            LCD_Goto(3,0);
     bca:	60 e0       	ldi	r22, 0x00	; 0
     bcc:	83 e0       	ldi	r24, 0x03	; 3
     bce:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
            LCD_WriteString("invalid");
     bd2:	8c ea       	ldi	r24, 0xAC	; 172
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
            return ERROR;
     bda:	80 e0       	ldi	r24, 0x00	; 0
     bdc:	47 c0       	rjmp	.+142    	; 0xc6c <SET+0x1a8>
        }
        array_section[0]=input_string[2];
        array_section[1]=input_string[3];

        if(atoi(array_section)>=0 && atoi(array_section)<60)
     bde:	ce 01       	movw	r24, r28
     be0:	01 96       	adiw	r24, 0x01	; 1
     be2:	0e 94 c9 09 	call	0x1392	; 0x1392 <atoi>
     be6:	cc 97       	sbiw	r24, 0x3c	; 60
     be8:	c4 f5       	brge	.+112    	; 0xc5a <SET+0x196>
        {
            INPUT_TIMERS[last_timer].seconds_user=atoi(array_section);
     bea:	00 91 b4 01 	lds	r16, 0x01B4	; 0x8001b4 <last_timer>
     bee:	10 e0       	ldi	r17, 0x00	; 0
     bf0:	ce 01       	movw	r24, r28
     bf2:	01 96       	adiw	r24, 0x01	; 1
     bf4:	0e 94 c9 09 	call	0x1392	; 0x1392 <atoi>
     bf8:	f8 01       	movw	r30, r16
     bfa:	ee 0f       	add	r30, r30
     bfc:	ff 1f       	adc	r31, r31
     bfe:	ee 0f       	add	r30, r30
     c00:	ff 1f       	adc	r31, r31
     c02:	ed 59       	subi	r30, 0x9D	; 157
     c04:	ff 4f       	sbci	r31, 0xFF	; 255
     c06:	80 83       	st	Z, r24
        {
            LCD_Goto(3,0);
            LCD_WriteString("invalid");
            return ERROR;
        }
        INPUT_TIMERS[last_timer].minutes_relative= minutes + INPUT_TIMERS[last_timer].minutes_user;
     c08:	80 91 b4 01 	lds	r24, 0x01B4	; 0x8001b4 <last_timer>
     c0c:	e8 2f       	mov	r30, r24
     c0e:	f0 e0       	ldi	r31, 0x00	; 0
     c10:	ee 0f       	add	r30, r30
     c12:	ff 1f       	adc	r31, r31
     c14:	ee 0f       	add	r30, r30
     c16:	ff 1f       	adc	r31, r31
     c18:	ed 59       	subi	r30, 0x9D	; 157
     c1a:	ff 4f       	sbci	r31, 0xFF	; 255
     c1c:	91 81       	ldd	r25, Z+1	; 0x01
     c1e:	20 91 a2 01 	lds	r18, 0x01A2	; 0x8001a2 <__data_end>
     c22:	30 91 a3 01 	lds	r19, 0x01A3	; 0x8001a3 <__data_end+0x1>
     c26:	29 0f       	add	r18, r25
     c28:	22 83       	std	Z+2, r18	; 0x02
        INPUT_TIMERS[last_timer].seconds_relative= seconds + INPUT_TIMERS[last_timer].seconds_user;
     c2a:	90 81       	ld	r25, Z
     c2c:	20 91 a4 01 	lds	r18, 0x01A4	; 0x8001a4 <seconds>
     c30:	30 91 a5 01 	lds	r19, 0x01A5	; 0x8001a5 <seconds+0x1>
     c34:	29 0f       	add	r18, r25
     c36:	23 83       	std	Z+3, r18	; 0x03

        last_timer++;
     c38:	8f 5f       	subi	r24, 0xFF	; 255
     c3a:	80 93 b4 01 	sts	0x01B4, r24	; 0x8001b4 <last_timer>
        LCD_Goto(3,0);
     c3e:	60 e0       	ldi	r22, 0x00	; 0
     c40:	83 e0       	ldi	r24, 0x03	; 3
     c42:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("success");
     c46:	84 eb       	ldi	r24, 0xB4	; 180
     c48:	90 e0       	ldi	r25, 0x00	; 0
     c4a:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        sorting_timers(INPUT_TIMERS);
     c4e:	83 e6       	ldi	r24, 0x63	; 99
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	0e 94 f6 04 	call	0x9ec	; 0x9ec <sorting_timers>

        return NO_ERROR;
     c56:	81 e0       	ldi	r24, 0x01	; 1
     c58:	09 c0       	rjmp	.+18     	; 0xc6c <SET+0x1a8>
        {
            INPUT_TIMERS[last_timer].seconds_user=atoi(array_section);
        }
        else
        {
            LCD_Goto(3,0);
     c5a:	60 e0       	ldi	r22, 0x00	; 0
     c5c:	83 e0       	ldi	r24, 0x03	; 3
     c5e:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
            LCD_WriteString("invalid");
     c62:	8c ea       	ldi	r24, 0xAC	; 172
     c64:	90 e0       	ldi	r25, 0x00	; 0
     c66:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
            return ERROR;
     c6a:	80 e0       	ldi	r24, 0x00	; 0
        LCD_Goto(3,0);
        LCD_WriteString("success");
        sorting_timers(INPUT_TIMERS);

        return NO_ERROR;
    }
     c6c:	28 96       	adiw	r28, 0x08	; 8
     c6e:	0f b6       	in	r0, 0x3f	; 63
     c70:	f8 94       	cli
     c72:	de bf       	out	0x3e, r29	; 62
     c74:	0f be       	out	0x3f, r0	; 63
     c76:	cd bf       	out	0x3d, r28	; 61
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	1f 91       	pop	r17
     c7e:	0f 91       	pop	r16
     c80:	08 95       	ret

00000c82 <cancel_timer>:


    error_status cancel_timer(uint8_t Timer_num)
    {
        if(Timer_num>3||Timer_num<=0)
     c82:	9f ef       	ldi	r25, 0xFF	; 255
     c84:	98 0f       	add	r25, r24
     c86:	93 30       	cpi	r25, 0x03	; 3
     c88:	c8 f4       	brcc	.+50     	; 0xcbc <cancel_timer+0x3a>
        {
            return Timer_Not_found;
        }
        else
        {
            INPUT_TIMERS[Timer_num-1].minutes_user=-1;
     c8a:	e8 2f       	mov	r30, r24
     c8c:	f0 e0       	ldi	r31, 0x00	; 0
     c8e:	31 97       	sbiw	r30, 0x01	; 1
     c90:	ee 0f       	add	r30, r30
     c92:	ff 1f       	adc	r31, r31
     c94:	ee 0f       	add	r30, r30
     c96:	ff 1f       	adc	r31, r31
     c98:	ed 59       	subi	r30, 0x9D	; 157
     c9a:	ff 4f       	sbci	r31, 0xFF	; 255
     c9c:	8f ef       	ldi	r24, 0xFF	; 255
     c9e:	81 83       	std	Z+1, r24	; 0x01
            INPUT_TIMERS[Timer_num-1].seconds_user=-1;
     ca0:	80 83       	st	Z, r24
            INPUT_TIMERS[Timer_num-1].seconds_relative=-1;
     ca2:	83 83       	std	Z+3, r24	; 0x03
            INPUT_TIMERS[Timer_num-1].minutes_relative=-1;
     ca4:	82 83       	std	Z+2, r24	; 0x02
            sorting_timers(INPUT_TIMERS);
     ca6:	83 e6       	ldi	r24, 0x63	; 99
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	0e 94 f6 04 	call	0x9ec	; 0x9ec <sorting_timers>

            last_timer--;
     cae:	80 91 b4 01 	lds	r24, 0x01B4	; 0x8001b4 <last_timer>
     cb2:	81 50       	subi	r24, 0x01	; 1
     cb4:	80 93 b4 01 	sts	0x01B4, r24	; 0x8001b4 <last_timer>
            return Time_deleted_successfully;
     cb8:	82 e0       	ldi	r24, 0x02	; 2
     cba:	08 95       	ret

    error_status cancel_timer(uint8_t Timer_num)
    {
        if(Timer_num>3||Timer_num<=0)
        {
            return Timer_Not_found;
     cbc:	83 e0       	ldi	r24, 0x03	; 3

            last_timer--;
            return Time_deleted_successfully;

        }
    }
     cbe:	08 95       	ret

00000cc0 <LDR_check>:


    u8 LDR_check(void)
    {

        ADC_ReadChannel(CHANNEL0);
     cc0:	80 e0       	ldi	r24, 0x00	; 0
     cc2:	0e 94 76 00 	call	0xec	; 0xec <ADC_ReadChannel>
        LCD_Goto(3,0);
     cc6:	60 e0       	ldi	r22, 0x00	; 0
     cc8:	83 e0       	ldi	r24, 0x03	; 3
     cca:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteNumber(Adc_Data);
     cce:	60 91 aa 01 	lds	r22, 0x01AA	; 0x8001aa <Adc_Data>
     cd2:	70 91 ab 01 	lds	r23, 0x01AB	; 0x8001ab <Adc_Data+0x1>
     cd6:	80 e0       	ldi	r24, 0x00	; 0
     cd8:	90 e0       	ldi	r25, 0x00	; 0
     cda:	0e 94 77 04 	call	0x8ee	; 0x8ee <LCD_WriteNumber>
        if (Adc_Data > 50)
     cde:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <Adc_Data>
     ce2:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <Adc_Data+0x1>
     ce6:	c3 97       	sbiw	r24, 0x33	; 51
     ce8:	10 f0       	brcs	.+4      	; 0xcee <LDR_check+0x2e>
        {
            return 1;
     cea:	81 e0       	ldi	r24, 0x01	; 1
     cec:	08 95       	ret
        }
        else
        {
            return 0;
     cee:	80 e0       	ldi	r24, 0x00	; 0
        }
    }
     cf0:	08 95       	ret

00000cf2 <Waking_sequence_Init>:

    error_status Waking_sequence_Init(void)
    {
     cf2:	cf 93       	push	r28
        
        u8 buzzer_time_sec = 7;
        u8 ldr_time_sec = 7;

        LCD_Clear();
     cf4:	0e 94 73 04 	call	0x8e6	; 0x8e6 <LCD_Clear>
        LCD_Goto(0, 0);
     cf8:	60 e0       	ldi	r22, 0x00	; 0
     cfa:	80 e0       	ldi	r24, 0x00	; 0
     cfc:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("     ALARM TIME     ");
     d00:	8c eb       	ldi	r24, 0xBC	; 188
     d02:	90 e0       	ldi	r25, 0x00	; 0
     d04:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>

        /*LED Brightening */
        LCD_Goto(2, 0);
     d08:	60 e0       	ldi	r22, 0x00	; 0
     d0a:	82 e0       	ldi	r24, 0x02	; 2
     d0c:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("Light brightening...");
     d10:	81 ed       	ldi	r24, 0xD1	; 209
     d12:	90 e0       	ldi	r25, 0x00	; 0
     d14:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        /*Configuring the timer*/
        

        for (u8 i = 2; i < 253; ++i)
     d18:	c2 e0       	ldi	r28, 0x02	; 2
     d1a:	10 c0       	rjmp	.+32     	; 0xd3c <Waking_sequence_Init+0x4a>
        {
            if (!LDR_check())
     d1c:	0e 94 60 06 	call	0xcc0	; 0xcc0 <LDR_check>
     d20:	81 11       	cpse	r24, r1
     d22:	05 c0       	rjmp	.+10     	; 0xd2e <Waking_sequence_Init+0x3c>
            {
                TIMER0_set_compare(i);
     d24:	8c 2f       	mov	r24, r28
     d26:	0e 94 41 09 	call	0x1282	; 0x1282 <TIMER0_set_compare>
        LCD_Goto(2, 0);
        LCD_WriteString("Light brightening...");
        /*Configuring the timer*/
        

        for (u8 i = 2; i < 253; ++i)
     d2a:	cf 5f       	subi	r28, 0xFF	; 255
     d2c:	07 c0       	rjmp	.+14     	; 0xd3c <Waking_sequence_Init+0x4a>
                TIMER0_set_compare(i);
               // _delay_ms(100);
            }
            else
            {
                LCD_Clear();
     d2e:	0e 94 73 04 	call	0x8e6	; 0x8e6 <LCD_Clear>
                LCD_WriteString("    Good Morning     ");
     d32:	86 ee       	ldi	r24, 0xE6	; 230
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
				//_delay_ms(2000);
                return;
     d3a:	66 c0       	rjmp	.+204    	; 0xe08 <Waking_sequence_Init+0x116>
        LCD_Goto(2, 0);
        LCD_WriteString("Light brightening...");
        /*Configuring the timer*/
        

        for (u8 i = 2; i < 253; ++i)
     d3c:	cd 3f       	cpi	r28, 0xFD	; 253
     d3e:	70 f3       	brcs	.-36     	; 0xd1c <Waking_sequence_Init+0x2a>
                return;
            }
        }


        LCD_Goto(2, 0);
     d40:	60 e0       	ldi	r22, 0x00	; 0
     d42:	82 e0       	ldi	r24, 0x02	; 2
     d44:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("                    ");
     d48:	8c ef       	ldi	r24, 0xFC	; 252
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        LCD_Goto(2, 0);
     d50:	60 e0       	ldi	r22, 0x00	; 0
     d52:	82 e0       	ldi	r24, 0x02	; 2
     d54:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("Buzzer will turn on in ");
     d58:	81 e1       	ldi	r24, 0x11	; 17
     d5a:	91 e0       	ldi	r25, 0x01	; 1
     d5c:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>

        /*Check exact name */
        buzzer_time_sec += seconds;
     d60:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <seconds>
     d64:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <seconds+0x1>
     d68:	c7 e0       	ldi	r28, 0x07	; 7
     d6a:	c8 0f       	add	r28, r24
        while (buzzer_time_sec < seconds)
     d6c:	15 c0       	rjmp	.+42     	; 0xd98 <Waking_sequence_Init+0xa6>
        {
            LCD_WriteNumber(buzzer_time_sec-seconds);
     d6e:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <seconds>
     d72:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <seconds+0x1>
     d76:	68 1b       	sub	r22, r24
     d78:	79 0b       	sbc	r23, r25
     d7a:	80 e0       	ldi	r24, 0x00	; 0
     d7c:	90 e0       	ldi	r25, 0x00	; 0
     d7e:	0e 94 77 04 	call	0x8ee	; 0x8ee <LCD_WriteNumber>
            if (LDR_check())
     d82:	0e 94 60 06 	call	0xcc0	; 0xcc0 <LDR_check>
     d86:	88 23       	and	r24, r24
     d88:	39 f0       	breq	.+14     	; 0xd98 <Waking_sequence_Init+0xa6>
            {
                LCD_Clear();
     d8a:	0e 94 73 04 	call	0x8e6	; 0x8e6 <LCD_Clear>
                LCD_WriteString("    Good Morning     ");
     d8e:	86 ee       	ldi	r24, 0xE6	; 230
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
				//_delay_ms(2000);
                return;
     d96:	38 c0       	rjmp	.+112    	; 0xe08 <Waking_sequence_Init+0x116>
        LCD_Goto(2, 0);
        LCD_WriteString("Buzzer will turn on in ");

        /*Check exact name */
        buzzer_time_sec += seconds;
        while (buzzer_time_sec < seconds)
     d98:	6c 2f       	mov	r22, r28
     d9a:	70 e0       	ldi	r23, 0x00	; 0
     d9c:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <seconds>
     da0:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <seconds+0x1>
     da4:	68 17       	cp	r22, r24
     da6:	79 07       	cpc	r23, r25
     da8:	10 f3       	brcs	.-60     	; 0xd6e <Waking_sequence_Init+0x7c>
                LCD_WriteString("    Good Morning     ");
				//_delay_ms(2000);
                return;
            }
        }
        LCD_Goto(2, 0);
     daa:	60 e0       	ldi	r22, 0x00	; 0
     dac:	82 e0       	ldi	r24, 0x02	; 2
     dae:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("                    ");
     db2:	8c ef       	ldi	r24, 0xFC	; 252
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        LCD_Goto(2, 0);
     dba:	60 e0       	ldi	r22, 0x00	; 0
     dbc:	82 e0       	ldi	r24, 0x02	; 2
     dbe:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("      Buzzer On     ");
     dc2:	89 e2       	ldi	r24, 0x29	; 41
     dc4:	91 e0       	ldi	r25, 0x01	; 1
     dc6:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        BUZZER_TurnOn(BUZZER1);
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	0e 94 ba 00 	call	0x174	; 0x174 <BUZZER_TurnOn>

        while (!LDR_check());
     dd0:	0e 94 60 06 	call	0xcc0	; 0xcc0 <LDR_check>
     dd4:	88 23       	and	r24, r24
     dd6:	e1 f3       	breq	.-8      	; 0xdd0 <Waking_sequence_Init+0xde>
        ldr_time_sec+=seconds;
     dd8:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <seconds>
     ddc:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <seconds+0x1>
     de0:	47 e0       	ldi	r20, 0x07	; 7
     de2:	48 0f       	add	r20, r24
        while (ldr_time_sec<seconds);
     de4:	84 2f       	mov	r24, r20
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	20 91 a4 01 	lds	r18, 0x01A4	; 0x8001a4 <seconds>
     dec:	30 91 a5 01 	lds	r19, 0x01A5	; 0x8001a5 <seconds+0x1>
     df0:	82 17       	cp	r24, r18
     df2:	93 07       	cpc	r25, r19
     df4:	b8 f3       	brcs	.-18     	; 0xde4 <Waking_sequence_Init+0xf2>

       // TIMER0_Deinit();
        BUZZER_TurnOff(BUZZER1);
     df6:	80 e0       	ldi	r24, 0x00	; 0
     df8:	0e 94 c9 00 	call	0x192	; 0x192 <BUZZER_TurnOff>
        LCD_Clear();
     dfc:	0e 94 73 04 	call	0x8e6	; 0x8e6 <LCD_Clear>
        LCD_WriteString("    Good Morning     ");
     e00:	86 ee       	ldi	r24, 0xE6	; 230
     e02:	90 e0       	ldi	r25, 0x00	; 0
     e04:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        matching==NO_MATCH;
		//_delay_ms(2000);
        return;
    }
     e08:	cf 91       	pop	r28
     e0a:	08 95       	ret

00000e0c <MATCH>:
    {
        u8 minutes_matchflag=0;
        u8 seconds_matchflag=0;
        u8 index_matching;

        for (u8 array =0; array < 3 ; array++)
     e0c:	80 e0       	ldi	r24, 0x00	; 0
    }

    void MATCH(void)
    {
        u8 minutes_matchflag=0;
        u8 seconds_matchflag=0;
     e0e:	a0 e0       	ldi	r26, 0x00	; 0
        return;
    }

    void MATCH(void)
    {
        u8 minutes_matchflag=0;
     e10:	90 e0       	ldi	r25, 0x00	; 0
        u8 seconds_matchflag=0;
        u8 index_matching;

        for (u8 array =0; array < 3 ; array++)
     e12:	2e c0       	rjmp	.+92     	; 0xe70 <MATCH+0x64>
        {
            if (INPUT_TIMERS[array].minutes_relative==minutes)
     e14:	48 2f       	mov	r20, r24
     e16:	50 e0       	ldi	r21, 0x00	; 0
     e18:	fa 01       	movw	r30, r20
     e1a:	ee 0f       	add	r30, r30
     e1c:	ff 1f       	adc	r31, r31
     e1e:	ee 0f       	add	r30, r30
     e20:	ff 1f       	adc	r31, r31
     e22:	ed 59       	subi	r30, 0x9D	; 157
     e24:	ff 4f       	sbci	r31, 0xFF	; 255
     e26:	22 81       	ldd	r18, Z+2	; 0x02
     e28:	02 2e       	mov	r0, r18
     e2a:	00 0c       	add	r0, r0
     e2c:	33 0b       	sbc	r19, r19
     e2e:	60 91 a2 01 	lds	r22, 0x01A2	; 0x8001a2 <__data_end>
     e32:	70 91 a3 01 	lds	r23, 0x01A3	; 0x8001a3 <__data_end+0x1>
     e36:	26 17       	cp	r18, r22
     e38:	37 07       	cpc	r19, r23
     e3a:	a9 f4       	brne	.+42     	; 0xe66 <MATCH+0x5a>
            {
                minutes_matchflag =1;
                if (INPUT_TIMERS[array].seconds_relative==seconds)
     e3c:	44 0f       	add	r20, r20
     e3e:	55 1f       	adc	r21, r21
     e40:	44 0f       	add	r20, r20
     e42:	55 1f       	adc	r21, r21
     e44:	fa 01       	movw	r30, r20
     e46:	ed 59       	subi	r30, 0x9D	; 157
     e48:	ff 4f       	sbci	r31, 0xFF	; 255
     e4a:	23 81       	ldd	r18, Z+3	; 0x03
     e4c:	02 2e       	mov	r0, r18
     e4e:	00 0c       	add	r0, r0
     e50:	33 0b       	sbc	r19, r19
     e52:	40 91 a4 01 	lds	r20, 0x01A4	; 0x8001a4 <seconds>
     e56:	50 91 a5 01 	lds	r21, 0x01A5	; 0x8001a5 <seconds+0x1>
     e5a:	24 17       	cp	r18, r20
     e5c:	35 07       	cpc	r19, r21
     e5e:	29 f4       	brne	.+10     	; 0xe6a <MATCH+0x5e>
                {
                    seconds_matchflag=1;
     e60:	a1 e0       	ldi	r26, 0x01	; 1

        for (u8 array =0; array < 3 ; array++)
        {
            if (INPUT_TIMERS[array].minutes_relative==minutes)
            {
                minutes_matchflag =1;
     e62:	91 e0       	ldi	r25, 0x01	; 1
     e64:	04 c0       	rjmp	.+8      	; 0xe6e <MATCH+0x62>
                    seconds_matchflag=0;
                }
            }
            else
            {
                minutes_matchflag=0;
     e66:	90 e0       	ldi	r25, 0x00	; 0
     e68:	02 c0       	rjmp	.+4      	; 0xe6e <MATCH+0x62>
                {
                    seconds_matchflag=1;
                }
                else
                {
                    seconds_matchflag=0;
     e6a:	a0 e0       	ldi	r26, 0x00	; 0

        for (u8 array =0; array < 3 ; array++)
        {
            if (INPUT_TIMERS[array].minutes_relative==minutes)
            {
                minutes_matchflag =1;
     e6c:	91 e0       	ldi	r25, 0x01	; 1
    {
        u8 minutes_matchflag=0;
        u8 seconds_matchflag=0;
        u8 index_matching;

        for (u8 array =0; array < 3 ; array++)
     e6e:	8f 5f       	subi	r24, 0xFF	; 255
     e70:	83 30       	cpi	r24, 0x03	; 3
     e72:	80 f2       	brcs	.-96     	; 0xe14 <MATCH+0x8>
            {
                minutes_matchflag=0;
            }
        }

        if (minutes_matchflag ==1 && seconds_matchflag ==1 )
     e74:	91 30       	cpi	r25, 0x01	; 1
     e76:	49 f4       	brne	.+18     	; 0xe8a <MATCH+0x7e>
     e78:	a1 30       	cpi	r26, 0x01	; 1
     e7a:	39 f4       	brne	.+14     	; 0xe8a <MATCH+0x7e>
        {
            cancel_timer(index_matching+1);
     e7c:	81 e0       	ldi	r24, 0x01	; 1
     e7e:	0e 94 41 06 	call	0xc82	; 0xc82 <cancel_timer>
            matching = MATCHED;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <matching>
     e88:	08 95       	ret
        }
        else
        {
            matching = NO_MATCH;
     e8a:	85 e0       	ldi	r24, 0x05	; 5
     e8c:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <matching>
     e90:	08 95       	ret

00000e92 <Display_menu>:
        }
    }

    void Display_menu(void)
    {
        LCD_Clear();
     e92:	0e 94 73 04 	call	0x8e6	; 0x8e6 <LCD_Clear>
        LCD_Goto (0,0);
     e96:	60 e0       	ldi	r22, 0x00	; 0
     e98:	80 e0       	ldi	r24, 0x00	; 0
     e9a:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("   Sunrise Alarm    ");
     e9e:	8e e3       	ldi	r24, 0x3E	; 62
     ea0:	91 e0       	ldi	r25, 0x01	; 1
     ea2:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        LCD_Goto(1,0);
     ea6:	60 e0       	ldi	r22, 0x00	; 0
     ea8:	81 e0       	ldi	r24, 0x01	; 1
     eaa:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString(" + : Set Alarm");
     eae:	83 e5       	ldi	r24, 0x53	; 83
     eb0:	91 e0       	ldi	r25, 0x01	; 1
     eb2:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        LCD_Goto(2,0);
     eb6:	60 e0       	ldi	r22, 0x00	; 0
     eb8:	82 e0       	ldi	r24, 0x02	; 2
     eba:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString(" - : Cancel Alarm");
     ebe:	82 e6       	ldi	r24, 0x62	; 98
     ec0:	91 e0       	ldi	r25, 0x01	; 1
     ec2:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        LCD_Goto(3,0);
     ec6:	60 e0       	ldi	r22, 0x00	; 0
     ec8:	83 e0       	ldi	r24, 0x03	; 3
     eca:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString(" * : Show Alarms ");
     ece:	84 e7       	ldi	r24, 0x74	; 116
     ed0:	91 e0       	ldi	r25, 0x01	; 1
     ed2:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        LCD_Goto(3,19);
     ed6:	63 e1       	ldi	r22, 0x13	; 19
     ed8:	83 e0       	ldi	r24, 0x03	; 3
     eda:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
     ede:	08 95       	ret

00000ee0 <Timers_Display>:
    }

    error_status Timers_Display(void)
    {
     ee0:	ff 92       	push	r15
     ee2:	0f 93       	push	r16
     ee4:	1f 93       	push	r17
     ee6:	cf 93       	push	r28
     ee8:	df 93       	push	r29
        LCD_Clear();
     eea:	0e 94 73 04 	call	0x8e6	; 0x8e6 <LCD_Clear>
        LCD_WriteString("The running timers:");
     eee:	86 e8       	ldi	r24, 0x86	; 134
     ef0:	91 e0       	ldi	r25, 0x01	; 1
     ef2:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        char buffer[2]= {0};
        for(int i=0; i<last_timer; i++)
     ef6:	c0 e0       	ldi	r28, 0x00	; 0
     ef8:	d0 e0       	ldi	r29, 0x00	; 0
     efa:	31 c0       	rjmp	.+98     	; 0xf5e <Timers_Display+0x7e>
        {
            LCD_Goto(i+1,0);
     efc:	fc 2e       	mov	r15, r28
     efe:	f3 94       	inc	r15
     f00:	60 e0       	ldi	r22, 0x00	; 0
     f02:	8f 2d       	mov	r24, r15
     f04:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
            LCD_WriteNumber(i+1);
     f08:	8e 01       	movw	r16, r28
     f0a:	0f 5f       	subi	r16, 0xFF	; 255
     f0c:	1f 4f       	sbci	r17, 0xFF	; 255
     f0e:	b8 01       	movw	r22, r16
     f10:	01 2e       	mov	r0, r17
     f12:	00 0c       	add	r0, r0
     f14:	88 0b       	sbc	r24, r24
     f16:	99 0b       	sbc	r25, r25
     f18:	0e 94 77 04 	call	0x8ee	; 0x8ee <LCD_WriteNumber>
            LCD_WriteChar('-');
     f1c:	8d e2       	ldi	r24, 0x2D	; 45
     f1e:	0e 94 b5 03 	call	0x76a	; 0x76a <LCD_WriteChar>
            LCD_Goto(i+1,3);
     f22:	63 e0       	ldi	r22, 0x03	; 3
     f24:	8f 2d       	mov	r24, r15
     f26:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
            LCD_WriteNumber(INPUT_TIMERS[i].minutes_relative);
     f2a:	cc 0f       	add	r28, r28
     f2c:	dd 1f       	adc	r29, r29
     f2e:	cc 0f       	add	r28, r28
     f30:	dd 1f       	adc	r29, r29
     f32:	cd 59       	subi	r28, 0x9D	; 157
     f34:	df 4f       	sbci	r29, 0xFF	; 255
     f36:	6a 81       	ldd	r22, Y+2	; 0x02
     f38:	06 2e       	mov	r0, r22
     f3a:	00 0c       	add	r0, r0
     f3c:	77 0b       	sbc	r23, r23
     f3e:	88 0b       	sbc	r24, r24
     f40:	99 0b       	sbc	r25, r25
     f42:	0e 94 77 04 	call	0x8ee	; 0x8ee <LCD_WriteNumber>
            LCD_WriteChar(':');
     f46:	8a e3       	ldi	r24, 0x3A	; 58
     f48:	0e 94 b5 03 	call	0x76a	; 0x76a <LCD_WriteChar>
            LCD_WriteNumber(INPUT_TIMERS[i].seconds_relative);
     f4c:	6b 81       	ldd	r22, Y+3	; 0x03
     f4e:	06 2e       	mov	r0, r22
     f50:	00 0c       	add	r0, r0
     f52:	77 0b       	sbc	r23, r23
     f54:	88 0b       	sbc	r24, r24
     f56:	99 0b       	sbc	r25, r25
     f58:	0e 94 77 04 	call	0x8ee	; 0x8ee <LCD_WriteNumber>
    error_status Timers_Display(void)
    {
        LCD_Clear();
        LCD_WriteString("The running timers:");
        char buffer[2]= {0};
        for(int i=0; i<last_timer; i++)
     f5c:	e8 01       	movw	r28, r16
     f5e:	80 91 b4 01 	lds	r24, 0x01B4	; 0x8001b4 <last_timer>
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	c8 17       	cp	r28, r24
     f66:	d9 07       	cpc	r29, r25
     f68:	4c f2       	brlt	.-110    	; 0xefc <Timers_Display+0x1c>
            LCD_WriteNumber(INPUT_TIMERS[i].minutes_relative);
            LCD_WriteChar(':');
            LCD_WriteNumber(INPUT_TIMERS[i].seconds_relative);

        }
        LCD_Goto(3,14);
     f6a:	6e e0       	ldi	r22, 0x0E	; 14
     f6c:	83 e0       	ldi	r24, 0x03	; 3
     f6e:	0e 94 4b 04 	call	0x896	; 0x896 <LCD_Goto>
        LCD_WriteString("0:Back");
     f72:	8a e9       	ldi	r24, 0x9A	; 154
     f74:	91 e0       	ldi	r25, 0x01	; 1
     f76:	0e 94 34 04 	call	0x868	; 0x868 <LCD_WriteString>
        clear_flag=0;
     f7a:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <clear_flag>
    }
     f7e:	df 91       	pop	r29
     f80:	cf 91       	pop	r28
     f82:	1f 91       	pop	r17
     f84:	0f 91       	pop	r16
     f86:	ff 90       	pop	r15
     f88:	08 95       	ret

00000f8a <runnable>:


    void runnable(void)
    {
        if(clear_flag ==1)
     f8a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <clear_flag>
     f8e:	81 30       	cpi	r24, 0x01	; 1
     f90:	a1 f4       	brne	.+40     	; 0xfba <runnable+0x30>
        {
            do
            {
                MATCH();
     f92:	0e 94 06 07 	call	0xe0c	; 0xe0c <MATCH>
                if (matching==MATCHED)
     f96:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <matching>
     f9a:	81 30       	cpi	r24, 0x01	; 1
     f9c:	11 f4       	brne	.+4      	; 0xfa2 <runnable+0x18>
                {
                    Waking_sequence_Init();
     f9e:	0e 94 79 06 	call	0xcf2	; 0xcf2 <Waking_sequence_Init>
                }
			   Display_menu();
     fa2:	0e 94 49 07 	call	0xe92	; 0xe92 <Display_menu>
               KeyPad_GetValue();
     fa6:	0e 94 8c 02 	call	0x518	; 0x518 <KeyPad_GetValue>
                

            }
            while((key!='+' && key!='*' && key!='-' ));
     faa:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     fae:	96 ed       	ldi	r25, 0xD6	; 214
     fb0:	98 0f       	add	r25, r24
     fb2:	92 30       	cpi	r25, 0x02	; 2
     fb4:	10 f0       	brcs	.+4      	; 0xfba <runnable+0x30>
     fb6:	8d 32       	cpi	r24, 0x2D	; 45
     fb8:	61 f7       	brne	.-40     	; 0xf92 <runnable+0x8>
        }

        LCD_Clear();
     fba:	0e 94 73 04 	call	0x8e6	; 0x8e6 <LCD_Clear>
        KeyPad_GetValue();
     fbe:	0e 94 8c 02 	call	0x518	; 0x518 <KeyPad_GetValue>
        if (key  =='0')
     fc2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     fc6:	80 33       	cpi	r24, 0x30	; 48
     fc8:	19 f4       	brne	.+6      	; 0xfd0 <runnable+0x46>
        {
            clear_flag =1;
     fca:	91 e0       	ldi	r25, 0x01	; 1
     fcc:	90 93 62 00 	sts	0x0062, r25	; 0x800062 <clear_flag>
        }
        switch (key)
     fd0:	8b 32       	cpi	r24, 0x2B	; 43
     fd2:	29 f0       	breq	.+10     	; 0xfde <runnable+0x54>
     fd4:	8d 32       	cpi	r24, 0x2D	; 45
     fd6:	71 f0       	breq	.+28     	; 0xff4 <runnable+0x6a>
     fd8:	8a 32       	cpi	r24, 0x2A	; 42
     fda:	e1 f5       	brne	.+120    	; 0x1054 <runnable+0xca>
     fdc:	31 c0       	rjmp	.+98     	; 0x1040 <runnable+0xb6>
        {
        case '+':
            SET();
     fde:	0e 94 62 05 	call	0xac4	; 0xac4 <SET>
            MATCH();
     fe2:	0e 94 06 07 	call	0xe0c	; 0xe0c <MATCH>
            if (matching==MATCHED)
     fe6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <matching>
     fea:	81 30       	cpi	r24, 0x01	; 1
     fec:	99 f5       	brne	.+102    	; 0x1054 <runnable+0xca>
            {
                Waking_sequence_Init();
     fee:	0e 94 79 06 	call	0xcf2	; 0xcf2 <Waking_sequence_Init>
     ff2:	30 c0       	rjmp	.+96     	; 0x1054 <runnable+0xca>
            }
            break;

        case '-':
            key='u';
     ff4:	85 e7       	ldi	r24, 0x75	; 117
     ff6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
            do
            {
                KeyPad_GetValue();
     ffa:	0e 94 8c 02 	call	0x518	; 0x518 <KeyPad_GetValue>
            }
            while(key=='u');
     ffe:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    1002:	85 37       	cpi	r24, 0x75	; 117
    1004:	d1 f3       	breq	.-12     	; 0xffa <runnable+0x70>
			if(key=='1')
    1006:	81 33       	cpi	r24, 0x31	; 49
    1008:	21 f4       	brne	.+8      	; 0x1012 <runnable+0x88>
				cancel_timer(1);
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	0e 94 41 06 	call	0xc82	; 0xc82 <cancel_timer>
    1010:	0b c0       	rjmp	.+22     	; 0x1028 <runnable+0x9e>
			else if (key=='2')
    1012:	82 33       	cpi	r24, 0x32	; 50
    1014:	21 f4       	brne	.+8      	; 0x101e <runnable+0x94>
				cancel_timer(2);
    1016:	82 e0       	ldi	r24, 0x02	; 2
    1018:	0e 94 41 06 	call	0xc82	; 0xc82 <cancel_timer>
    101c:	05 c0       	rjmp	.+10     	; 0x1028 <runnable+0x9e>
			else if(key=='3')
    101e:	83 33       	cpi	r24, 0x33	; 51
    1020:	19 f4       	brne	.+6      	; 0x1028 <runnable+0x9e>
				cancel_timer(3);
    1022:	83 e0       	ldi	r24, 0x03	; 3
    1024:	0e 94 41 06 	call	0xc82	; 0xc82 <cancel_timer>
            key='u';
    1028:	85 e7       	ldi	r24, 0x75	; 117
    102a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
            MATCH();
    102e:	0e 94 06 07 	call	0xe0c	; 0xe0c <MATCH>
            if (matching==MATCHED)
    1032:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <matching>
    1036:	81 30       	cpi	r24, 0x01	; 1
    1038:	69 f4       	brne	.+26     	; 0x1054 <runnable+0xca>
            {
                Waking_sequence_Init();
    103a:	0e 94 79 06 	call	0xcf2	; 0xcf2 <Waking_sequence_Init>
    103e:	0a c0       	rjmp	.+20     	; 0x1054 <runnable+0xca>
            }
            break;

        case'*':
            Timers_Display();
    1040:	0e 94 70 07 	call	0xee0	; 0xee0 <Timers_Display>
            MATCH();
    1044:	0e 94 06 07 	call	0xe0c	; 0xe0c <MATCH>
            if (matching==MATCHED)
    1048:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <matching>
    104c:	81 30       	cpi	r24, 0x01	; 1
    104e:	11 f4       	brne	.+4      	; 0x1054 <runnable+0xca>
            {
                Waking_sequence_Init();
    1050:	0e 94 79 06 	call	0xcf2	; 0xcf2 <Waking_sequence_Init>
            break;

        
        }

        MATCH();
    1054:	0e 94 06 07 	call	0xe0c	; 0xe0c <MATCH>
        if (matching==MATCHED)
    1058:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <matching>
    105c:	81 30       	cpi	r24, 0x01	; 1
    105e:	11 f4       	brne	.+4      	; 0x1064 <runnable+0xda>
        {
            Waking_sequence_Init();
    1060:	0e 94 79 06 	call	0xcf2	; 0xcf2 <Waking_sequence_Init>
    1064:	08 95       	ret

00001066 <Init>:
        }
    }
	
void Init(){
    1066:	cf 93       	push	r28
    1068:	df 93       	push	r29
    106a:	00 d0       	rcall	.+0      	; 0x106c <Init+0x6>
    106c:	00 d0       	rcall	.+0      	; 0x106e <Init+0x8>
    106e:	00 d0       	rcall	.+0      	; 0x1070 <Init+0xa>
    1070:	cd b7       	in	r28, 0x3d	; 61
    1072:	de b7       	in	r29, 0x3e	; 62
	LCD_Init();
    1074:	0e 94 75 03 	call	0x6ea	; 0x6ea <LCD_Init>
	DIO_SetPinDirection(DIO_PORTB,DIO_PIN3,DIO_PIN_OUTPUT);
    1078:	41 e0       	ldi	r20, 0x01	; 1
    107a:	63 e0       	ldi	r22, 0x03	; 3
    107c:	81 e0       	ldi	r24, 0x01	; 1
    107e:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_SetPinDirection>
	TIMER_ConfigType ConfigStruct = {NORMAL_MODE,F_CPU_1024_2,247};
    1082:	ce 01       	movw	r24, r28
    1084:	01 96       	adiw	r24, 0x01	; 1
    1086:	26 e0       	ldi	r18, 0x06	; 6
    1088:	fc 01       	movw	r30, r24
    108a:	11 92       	st	Z+, r1
    108c:	2a 95       	dec	r18
    108e:	e9 f7       	brne	.-6      	; 0x108a <Init+0x24>
    1090:	27 e0       	ldi	r18, 0x07	; 7
    1092:	2a 83       	std	Y+2, r18	; 0x02
    1094:	27 ef       	ldi	r18, 0xF7	; 247
    1096:	2b 83       	std	Y+3, r18	; 0x03
	TIMER2_Init(&ConfigStruct);
    1098:	0e 94 72 08 	call	0x10e4	; 0x10e4 <TIMER2_Init>
	keyPad_Init();
    109c:	0e 94 53 02 	call	0x4a6	; 0x4a6 <keyPad_Init>
	ADC_Init_N(VREF_VCC, ADC_SCALER_128);
    10a0:	67 e0       	ldi	r22, 0x07	; 7
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	0e 94 49 00 	call	0x92	; 0x92 <ADC_Init_N>
	timer0_config.enu_timer0_prescaler = TIMER_PRESCALER_1024;
    10a8:	ec ea       	ldi	r30, 0xAC	; 172
    10aa:	f1 e0       	ldi	r31, 0x01	; 1
    10ac:	85 e0       	ldi	r24, 0x05	; 5
    10ae:	80 83       	st	Z, r24
	timer0_config.enu_timer0_mode = PWM_FAST;
    10b0:	83 e0       	ldi	r24, 0x03	; 3
    10b2:	81 83       	std	Z+1, r24	; 0x01
	timer0_config.enu_timer0_int_en = POLLING;
    10b4:	12 82       	std	Z+2, r1	; 0x02
	timer0_config.enu_timer0_oc0 = CLEAR_OC0;
    10b6:	82 e0       	ldi	r24, 0x02	; 2
    10b8:	83 83       	std	Z+3, r24	; 0x03
	timer0_config.compare_val = 0;
    10ba:	15 82       	std	Z+5, r1	; 0x05
	timer0_config.preload = 0;
    10bc:	14 82       	std	Z+4, r1	; 0x04
	TIMER0_Init(&timer0_config);
    10be:	cf 01       	movw	r24, r30
    10c0:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <TIMER0_Init>
	TIMER2_setCallBack(count_time);
    10c4:	84 ec       	ldi	r24, 0xC4	; 196
    10c6:	94 e0       	ldi	r25, 0x04	; 4
    10c8:	0e 94 65 09 	call	0x12ca	; 0x12ca <TIMER2_setCallBack>
	SET_BIT(SREG,7);
    10cc:	8f b7       	in	r24, 0x3f	; 63
    10ce:	80 68       	ori	r24, 0x80	; 128
    10d0:	8f bf       	out	0x3f, r24	; 63
    10d2:	26 96       	adiw	r28, 0x06	; 6
    10d4:	0f b6       	in	r0, 0x3f	; 63
    10d6:	f8 94       	cli
    10d8:	de bf       	out	0x3e, r29	; 62
    10da:	0f be       	out	0x3f, r0	; 63
    10dc:	cd bf       	out	0x3d, r28	; 61
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	08 95       	ret

000010e4 <TIMER2_Init>:
		return SUCCESSFUL;
	}
	else
	return UNSUCCESSFUL;
	
}
    10e4:	fc 01       	movw	r30, r24
    10e6:	95 b5       	in	r25, 0x25	; 37
    10e8:	9f 77       	andi	r25, 0x7F	; 127
    10ea:	95 bd       	out	0x25, r25	; 37
    10ec:	20 81       	ld	r18, Z
    10ee:	22 30       	cpi	r18, 0x02	; 2
    10f0:	28 f0       	brcs	.+10     	; 0x10fc <TIMER2_Init+0x18>
    10f2:	29 30       	cpi	r18, 0x09	; 9
    10f4:	19 f0       	breq	.+6      	; 0x10fc <TIMER2_Init+0x18>
    10f6:	28 30       	cpi	r18, 0x08	; 8
    10f8:	09 f0       	breq	.+2      	; 0x10fc <TIMER2_Init+0x18>
    10fa:	53 c0       	rjmp	.+166    	; 0x11a2 <TIMER2_Init+0xbe>
    10fc:	85 b5       	in	r24, 0x25	; 37
    10fe:	30 e0       	ldi	r19, 0x00	; 0
    1100:	22 0f       	add	r18, r18
    1102:	33 1f       	adc	r19, r19
    1104:	22 0f       	add	r18, r18
    1106:	33 1f       	adc	r19, r19
    1108:	22 0f       	add	r18, r18
    110a:	33 1f       	adc	r19, r19
    110c:	87 7b       	andi	r24, 0xB7	; 183
    110e:	28 2b       	or	r18, r24
    1110:	25 bd       	out	0x25, r18	; 37
    1112:	81 81       	ldd	r24, Z+1	; 0x01
    1114:	88 30       	cpi	r24, 0x08	; 8
    1116:	08 f0       	brcs	.+2      	; 0x111a <TIMER2_Init+0x36>
    1118:	40 c0       	rjmp	.+128    	; 0x119a <TIMER2_Init+0xb6>
    111a:	95 b5       	in	r25, 0x25	; 37
    111c:	98 7f       	andi	r25, 0xF8	; 248
    111e:	89 2b       	or	r24, r25
    1120:	85 bd       	out	0x25, r24	; 37
    1122:	80 81       	ld	r24, Z
    1124:	81 11       	cpse	r24, r1
    1126:	06 c0       	rjmp	.+12     	; 0x1134 <TIMER2_Init+0x50>
    1128:	82 81       	ldd	r24, Z+2	; 0x02
    112a:	84 bd       	out	0x24, r24	; 36
    112c:	89 b7       	in	r24, 0x39	; 57
    112e:	80 64       	ori	r24, 0x40	; 64
    1130:	89 bf       	out	0x39, r24	; 57
    1132:	39 c0       	rjmp	.+114    	; 0x11a6 <TIMER2_Init+0xc2>
    1134:	81 30       	cpi	r24, 0x01	; 1
    1136:	b9 f4       	brne	.+46     	; 0x1166 <TIMER2_Init+0x82>
    1138:	84 81       	ldd	r24, Z+4	; 0x04
    113a:	84 30       	cpi	r24, 0x04	; 4
    113c:	80 f4       	brcc	.+32     	; 0x115e <TIMER2_Init+0x7a>
    113e:	25 b5       	in	r18, 0x25	; 37
    1140:	30 e1       	ldi	r19, 0x10	; 16
    1142:	83 9f       	mul	r24, r19
    1144:	c0 01       	movw	r24, r0
    1146:	11 24       	eor	r1, r1
    1148:	92 2f       	mov	r25, r18
    114a:	9f 7c       	andi	r25, 0xCF	; 207
    114c:	89 2b       	or	r24, r25
    114e:	85 bd       	out	0x25, r24	; 37
    1150:	14 bc       	out	0x24, r1	; 36
    1152:	83 81       	ldd	r24, Z+3	; 0x03
    1154:	83 bd       	out	0x23, r24	; 35
    1156:	89 b7       	in	r24, 0x39	; 57
    1158:	80 68       	ori	r24, 0x80	; 128
    115a:	89 bf       	out	0x39, r24	; 57
    115c:	24 c0       	rjmp	.+72     	; 0x11a6 <TIMER2_Init+0xc2>
    115e:	82 e0       	ldi	r24, 0x02	; 2
    1160:	80 93 b6 01 	sts	0x01B6, r24	; 0x8001b6 <Error_Init2>
    1164:	20 c0       	rjmp	.+64     	; 0x11a6 <TIMER2_Init+0xc2>
    1166:	89 30       	cpi	r24, 0x09	; 9
    1168:	f1 f4       	brne	.+60     	; 0x11a6 <TIMER2_Init+0xc2>
    116a:	85 81       	ldd	r24, Z+5	; 0x05
    116c:	84 30       	cpi	r24, 0x04	; 4
    116e:	88 f4       	brcc	.+34     	; 0x1192 <TIMER2_Init+0xae>
    1170:	25 b5       	in	r18, 0x25	; 37
    1172:	30 e1       	ldi	r19, 0x10	; 16
    1174:	83 9f       	mul	r24, r19
    1176:	c0 01       	movw	r24, r0
    1178:	11 24       	eor	r1, r1
    117a:	92 2f       	mov	r25, r18
    117c:	9f 7c       	andi	r25, 0xCF	; 207
    117e:	89 2b       	or	r24, r25
    1180:	85 bd       	out	0x25, r24	; 37
    1182:	14 bc       	out	0x24, r1	; 36
    1184:	13 bc       	out	0x23, r1	; 35
    1186:	82 81       	ldd	r24, Z+2	; 0x02
    1188:	84 bd       	out	0x24, r24	; 36
    118a:	89 b7       	in	r24, 0x39	; 57
    118c:	80 64       	ori	r24, 0x40	; 64
    118e:	89 bf       	out	0x39, r24	; 57
    1190:	0a c0       	rjmp	.+20     	; 0x11a6 <TIMER2_Init+0xc2>
    1192:	83 e0       	ldi	r24, 0x03	; 3
    1194:	80 93 b6 01 	sts	0x01B6, r24	; 0x8001b6 <Error_Init2>
    1198:	06 c0       	rjmp	.+12     	; 0x11a6 <TIMER2_Init+0xc2>
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	80 93 b6 01 	sts	0x01B6, r24	; 0x8001b6 <Error_Init2>
    11a0:	02 c0       	rjmp	.+4      	; 0x11a6 <TIMER2_Init+0xc2>
    11a2:	10 92 b6 01 	sts	0x01B6, r1	; 0x8001b6 <Error_Init2>
    11a6:	80 91 b6 01 	lds	r24, 0x01B6	; 0x8001b6 <Error_Init2>
    11aa:	81 11       	cpse	r24, r1
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	08 95       	ret

000011b0 <TIMER0_Init>:
    11b0:	fc 01       	movw	r30, r24
    11b2:	80 81       	ld	r24, Z
    11b4:	87 30       	cpi	r24, 0x07	; 7
    11b6:	08 f0       	brcs	.+2      	; 0x11ba <TIMER0_Init+0xa>
    11b8:	5c c0       	rjmp	.+184    	; 0x1272 <TIMER0_Init+0xc2>
    11ba:	81 81       	ldd	r24, Z+1	; 0x01
    11bc:	85 30       	cpi	r24, 0x05	; 5
    11be:	08 f0       	brcs	.+2      	; 0x11c2 <TIMER0_Init+0x12>
    11c0:	5a c0       	rjmp	.+180    	; 0x1276 <TIMER0_Init+0xc6>
    11c2:	92 81       	ldd	r25, Z+2	; 0x02
    11c4:	94 30       	cpi	r25, 0x04	; 4
    11c6:	08 f0       	brcs	.+2      	; 0x11ca <TIMER0_Init+0x1a>
    11c8:	58 c0       	rjmp	.+176    	; 0x127a <TIMER0_Init+0xca>
    11ca:	93 81       	ldd	r25, Z+3	; 0x03
    11cc:	95 30       	cpi	r25, 0x05	; 5
    11ce:	08 f0       	brcs	.+2      	; 0x11d2 <TIMER0_Init+0x22>
    11d0:	56 c0       	rjmp	.+172    	; 0x127e <TIMER0_Init+0xce>
    11d2:	81 30       	cpi	r24, 0x01	; 1
    11d4:	39 f1       	breq	.+78     	; 0x1224 <TIMER0_Init+0x74>
    11d6:	80 f0       	brcs	.+32     	; 0x11f8 <TIMER0_Init+0x48>
    11d8:	82 30       	cpi	r24, 0x02	; 2
    11da:	19 f0       	breq	.+6      	; 0x11e2 <TIMER0_Init+0x32>
    11dc:	83 30       	cpi	r24, 0x03	; 3
    11de:	b9 f0       	breq	.+46     	; 0x120e <TIMER0_Init+0x5e>
    11e0:	2c c0       	rjmp	.+88     	; 0x123a <TIMER0_Init+0x8a>
    11e2:	83 b7       	in	r24, 0x33	; 51
    11e4:	88 60       	ori	r24, 0x08	; 8
    11e6:	83 bf       	out	0x33, r24	; 51
    11e8:	83 b7       	in	r24, 0x33	; 51
    11ea:	8f 7b       	andi	r24, 0xBF	; 191
    11ec:	83 bf       	out	0x33, r24	; 51
    11ee:	83 b7       	in	r24, 0x33	; 51
    11f0:	80 68       	ori	r24, 0x80	; 128
    11f2:	83 bf       	out	0x33, r24	; 51
    11f4:	80 e0       	ldi	r24, 0x00	; 0
    11f6:	22 c0       	rjmp	.+68     	; 0x123c <TIMER0_Init+0x8c>
    11f8:	83 b7       	in	r24, 0x33	; 51
    11fa:	8f 7b       	andi	r24, 0xBF	; 191
    11fc:	83 bf       	out	0x33, r24	; 51
    11fe:	83 b7       	in	r24, 0x33	; 51
    1200:	87 7f       	andi	r24, 0xF7	; 247
    1202:	83 bf       	out	0x33, r24	; 51
    1204:	83 b7       	in	r24, 0x33	; 51
    1206:	80 68       	ori	r24, 0x80	; 128
    1208:	83 bf       	out	0x33, r24	; 51
    120a:	80 e0       	ldi	r24, 0x00	; 0
    120c:	17 c0       	rjmp	.+46     	; 0x123c <TIMER0_Init+0x8c>
    120e:	83 b7       	in	r24, 0x33	; 51
    1210:	88 60       	ori	r24, 0x08	; 8
    1212:	83 bf       	out	0x33, r24	; 51
    1214:	83 b7       	in	r24, 0x33	; 51
    1216:	80 64       	ori	r24, 0x40	; 64
    1218:	83 bf       	out	0x33, r24	; 51
    121a:	83 b7       	in	r24, 0x33	; 51
    121c:	8f 77       	andi	r24, 0x7F	; 127
    121e:	83 bf       	out	0x33, r24	; 51
    1220:	80 e0       	ldi	r24, 0x00	; 0
    1222:	0c c0       	rjmp	.+24     	; 0x123c <TIMER0_Init+0x8c>
    1224:	83 b7       	in	r24, 0x33	; 51
    1226:	87 7f       	andi	r24, 0xF7	; 247
    1228:	83 bf       	out	0x33, r24	; 51
    122a:	83 b7       	in	r24, 0x33	; 51
    122c:	80 64       	ori	r24, 0x40	; 64
    122e:	83 bf       	out	0x33, r24	; 51
    1230:	83 b7       	in	r24, 0x33	; 51
    1232:	8f 77       	andi	r24, 0x7F	; 127
    1234:	83 bf       	out	0x33, r24	; 51
    1236:	80 e0       	ldi	r24, 0x00	; 0
    1238:	01 c0       	rjmp	.+2      	; 0x123c <TIMER0_Init+0x8c>
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	95 81       	ldd	r25, Z+5	; 0x05
    123e:	9c bf       	out	0x3c, r25	; 60
    1240:	23 b7       	in	r18, 0x33	; 51
    1242:	90 81       	ld	r25, Z
    1244:	92 2b       	or	r25, r18
    1246:	93 bf       	out	0x33, r25	; 51
    1248:	43 b7       	in	r20, 0x33	; 51
    124a:	93 81       	ldd	r25, Z+3	; 0x03
    124c:	50 e1       	ldi	r21, 0x10	; 16
    124e:	95 9f       	mul	r25, r21
    1250:	90 01       	movw	r18, r0
    1252:	11 24       	eor	r1, r1
    1254:	24 2b       	or	r18, r20
    1256:	23 bf       	out	0x33, r18	; 51
    1258:	92 81       	ldd	r25, Z+2	; 0x02
    125a:	99 23       	and	r25, r25
    125c:	29 f0       	breq	.+10     	; 0x1268 <TIMER0_Init+0xb8>
    125e:	78 94       	sei
    1260:	29 b7       	in	r18, 0x39	; 57
    1262:	92 81       	ldd	r25, Z+2	; 0x02
    1264:	92 2b       	or	r25, r18
    1266:	99 bf       	out	0x39, r25	; 57
    1268:	22 b7       	in	r18, 0x32	; 50
    126a:	94 81       	ldd	r25, Z+4	; 0x04
    126c:	92 2b       	or	r25, r18
    126e:	92 bf       	out	0x32, r25	; 50
    1270:	08 95       	ret
    1272:	81 e0       	ldi	r24, 0x01	; 1
    1274:	08 95       	ret
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	08 95       	ret
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	08 95       	ret
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	08 95       	ret

00001282 <TIMER0_set_compare>:
    1282:	8c bf       	out	0x3c, r24	; 60
    1284:	80 e0       	ldi	r24, 0x00	; 0
    1286:	08 95       	ret

00001288 <__vector_11>:
    1288:	1f 92       	push	r1
    128a:	0f 92       	push	r0
    128c:	0f b6       	in	r0, 0x3f	; 63
    128e:	0f 92       	push	r0
    1290:	11 24       	eor	r1, r1
    1292:	8f 93       	push	r24
    1294:	9f 93       	push	r25
    1296:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <OVF_Counter>
    129a:	90 91 a7 01 	lds	r25, 0x01A7	; 0x8001a7 <OVF_Counter+0x1>
    129e:	01 96       	adiw	r24, 0x01	; 1
    12a0:	90 93 a7 01 	sts	0x01A7, r25	; 0x8001a7 <OVF_Counter+0x1>
    12a4:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <OVF_Counter>
    12a8:	4f 97       	sbiw	r24, 0x1f	; 31
    12aa:	41 f4       	brne	.+16     	; 0x12bc <__vector_11+0x34>
    12ac:	9b b3       	in	r25, 0x1b	; 27
    12ae:	80 e2       	ldi	r24, 0x20	; 32
    12b0:	89 27       	eor	r24, r25
    12b2:	8b bb       	out	0x1b, r24	; 27
    12b4:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <OVF_Counter+0x1>
    12b8:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <OVF_Counter>
    12bc:	9f 91       	pop	r25
    12be:	8f 91       	pop	r24
    12c0:	0f 90       	pop	r0
    12c2:	0f be       	out	0x3f, r0	; 63
    12c4:	0f 90       	pop	r0
    12c6:	1f 90       	pop	r1
    12c8:	18 95       	reti

000012ca <TIMER2_setCallBack>:



void TIMER2_setCallBack(void (*a_ptr)(void)){
	
	g_timer2CallBackPtr=a_ptr;
    12ca:	90 93 a9 01 	sts	0x01A9, r25	; 0x8001a9 <g_timer2CallBackPtr+0x1>
    12ce:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <g_timer2CallBackPtr>
    12d2:	08 95       	ret

000012d4 <__vector_5>:
}

ISR(TIMER2_OVF_vect){
    12d4:	1f 92       	push	r1
    12d6:	0f 92       	push	r0
    12d8:	0f b6       	in	r0, 0x3f	; 63
    12da:	0f 92       	push	r0
    12dc:	11 24       	eor	r1, r1
    12de:	2f 93       	push	r18
    12e0:	3f 93       	push	r19
    12e2:	4f 93       	push	r20
    12e4:	5f 93       	push	r21
    12e6:	6f 93       	push	r22
    12e8:	7f 93       	push	r23
    12ea:	8f 93       	push	r24
    12ec:	9f 93       	push	r25
    12ee:	af 93       	push	r26
    12f0:	bf 93       	push	r27
    12f2:	ef 93       	push	r30
    12f4:	ff 93       	push	r31
	if(g_timer2CallBackPtr != NULL_PTR){
    12f6:	e0 91 a8 01 	lds	r30, 0x01A8	; 0x8001a8 <g_timer2CallBackPtr>
    12fa:	f0 91 a9 01 	lds	r31, 0x01A9	; 0x8001a9 <g_timer2CallBackPtr+0x1>
    12fe:	30 97       	sbiw	r30, 0x00	; 0
    1300:	09 f0       	breq	.+2      	; 0x1304 <__vector_5+0x30>
		(*g_timer2CallBackPtr)();
    1302:	09 95       	icall
	}
}
    1304:	ff 91       	pop	r31
    1306:	ef 91       	pop	r30
    1308:	bf 91       	pop	r27
    130a:	af 91       	pop	r26
    130c:	9f 91       	pop	r25
    130e:	8f 91       	pop	r24
    1310:	7f 91       	pop	r23
    1312:	6f 91       	pop	r22
    1314:	5f 91       	pop	r21
    1316:	4f 91       	pop	r20
    1318:	3f 91       	pop	r19
    131a:	2f 91       	pop	r18
    131c:	0f 90       	pop	r0
    131e:	0f be       	out	0x3f, r0	; 63
    1320:	0f 90       	pop	r0
    1322:	1f 90       	pop	r1
    1324:	18 95       	reti

00001326 <__udivmodhi4>:
    1326:	aa 1b       	sub	r26, r26
    1328:	bb 1b       	sub	r27, r27
    132a:	51 e1       	ldi	r21, 0x11	; 17
    132c:	07 c0       	rjmp	.+14     	; 0x133c <__udivmodhi4_ep>

0000132e <__udivmodhi4_loop>:
    132e:	aa 1f       	adc	r26, r26
    1330:	bb 1f       	adc	r27, r27
    1332:	a6 17       	cp	r26, r22
    1334:	b7 07       	cpc	r27, r23
    1336:	10 f0       	brcs	.+4      	; 0x133c <__udivmodhi4_ep>
    1338:	a6 1b       	sub	r26, r22
    133a:	b7 0b       	sbc	r27, r23

0000133c <__udivmodhi4_ep>:
    133c:	88 1f       	adc	r24, r24
    133e:	99 1f       	adc	r25, r25
    1340:	5a 95       	dec	r21
    1342:	a9 f7       	brne	.-22     	; 0x132e <__udivmodhi4_loop>
    1344:	80 95       	com	r24
    1346:	90 95       	com	r25
    1348:	bc 01       	movw	r22, r24
    134a:	cd 01       	movw	r24, r26
    134c:	08 95       	ret

0000134e <__udivmodsi4>:
    134e:	a1 e2       	ldi	r26, 0x21	; 33
    1350:	1a 2e       	mov	r1, r26
    1352:	aa 1b       	sub	r26, r26
    1354:	bb 1b       	sub	r27, r27
    1356:	fd 01       	movw	r30, r26
    1358:	0d c0       	rjmp	.+26     	; 0x1374 <__udivmodsi4_ep>

0000135a <__udivmodsi4_loop>:
    135a:	aa 1f       	adc	r26, r26
    135c:	bb 1f       	adc	r27, r27
    135e:	ee 1f       	adc	r30, r30
    1360:	ff 1f       	adc	r31, r31
    1362:	a2 17       	cp	r26, r18
    1364:	b3 07       	cpc	r27, r19
    1366:	e4 07       	cpc	r30, r20
    1368:	f5 07       	cpc	r31, r21
    136a:	20 f0       	brcs	.+8      	; 0x1374 <__udivmodsi4_ep>
    136c:	a2 1b       	sub	r26, r18
    136e:	b3 0b       	sbc	r27, r19
    1370:	e4 0b       	sbc	r30, r20
    1372:	f5 0b       	sbc	r31, r21

00001374 <__udivmodsi4_ep>:
    1374:	66 1f       	adc	r22, r22
    1376:	77 1f       	adc	r23, r23
    1378:	88 1f       	adc	r24, r24
    137a:	99 1f       	adc	r25, r25
    137c:	1a 94       	dec	r1
    137e:	69 f7       	brne	.-38     	; 0x135a <__udivmodsi4_loop>
    1380:	60 95       	com	r22
    1382:	70 95       	com	r23
    1384:	80 95       	com	r24
    1386:	90 95       	com	r25
    1388:	9b 01       	movw	r18, r22
    138a:	ac 01       	movw	r20, r24
    138c:	bd 01       	movw	r22, r26
    138e:	cf 01       	movw	r24, r30
    1390:	08 95       	ret

00001392 <atoi>:
    1392:	fc 01       	movw	r30, r24
    1394:	88 27       	eor	r24, r24
    1396:	99 27       	eor	r25, r25
    1398:	e8 94       	clt
    139a:	21 91       	ld	r18, Z+
    139c:	20 32       	cpi	r18, 0x20	; 32
    139e:	e9 f3       	breq	.-6      	; 0x139a <atoi+0x8>
    13a0:	29 30       	cpi	r18, 0x09	; 9
    13a2:	10 f0       	brcs	.+4      	; 0x13a8 <atoi+0x16>
    13a4:	2e 30       	cpi	r18, 0x0E	; 14
    13a6:	c8 f3       	brcs	.-14     	; 0x139a <atoi+0x8>
    13a8:	2b 32       	cpi	r18, 0x2B	; 43
    13aa:	41 f0       	breq	.+16     	; 0x13bc <atoi+0x2a>
    13ac:	2d 32       	cpi	r18, 0x2D	; 45
    13ae:	39 f4       	brne	.+14     	; 0x13be <atoi+0x2c>
    13b0:	68 94       	set
    13b2:	04 c0       	rjmp	.+8      	; 0x13bc <atoi+0x2a>
    13b4:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__mulhi_const_10>
    13b8:	82 0f       	add	r24, r18
    13ba:	91 1d       	adc	r25, r1
    13bc:	21 91       	ld	r18, Z+
    13be:	20 53       	subi	r18, 0x30	; 48
    13c0:	2a 30       	cpi	r18, 0x0A	; 10
    13c2:	c0 f3       	brcs	.-16     	; 0x13b4 <atoi+0x22>
    13c4:	1e f4       	brtc	.+6      	; 0x13cc <atoi+0x3a>
    13c6:	90 95       	com	r25
    13c8:	81 95       	neg	r24
    13ca:	9f 4f       	sbci	r25, 0xFF	; 255
    13cc:	08 95       	ret

000013ce <__mulhi_const_10>:
    13ce:	7a e0       	ldi	r23, 0x0A	; 10
    13d0:	97 9f       	mul	r25, r23
    13d2:	90 2d       	mov	r25, r0
    13d4:	87 9f       	mul	r24, r23
    13d6:	80 2d       	mov	r24, r0
    13d8:	91 0d       	add	r25, r1
    13da:	11 24       	eor	r1, r1
    13dc:	08 95       	ret

000013de <_exit>:
    13de:	f8 94       	cli

000013e0 <__stop_program>:
    13e0:	ff cf       	rjmp	.-2      	; 0x13e0 <__stop_program>
